<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Алгоритмы сортировки</h4>
                </section>
                <section>
                    <h4>Задача сортировки</h4>
                    <ul>
                        <li>Дано: последовательность элементов $a_1, a_2, \ldots, a_N$</li>
                        <li>Найти: последовательность индексов $i_1, i_2, \ldots, i_N$ таких, что: $$ a_{i_1} \leqslant a_{i_2} \leqslant \ldots \leqslant a_{i_N} $$</li>
                    </ul>                    
                </section>
                <section>
                    <section>
                        <h4>Сортировка пузырьком (bubble sort)</h4>
                        <ol>
                            <li>Для $i$ от $1$ до $N - 1$ выполнять:</li>
                            <ol>
                                <li>Для $j$ от $1$ до $N - i$ выполнять:</li>
                                <ol>
                                    <li>Если $a_j &gt; a_{j + 1}$:</li>
                                    <ol>
                                        <li>Обменять местами $a_j$ и $a_{j + 1}$</li>
                                    </ol>
                                </ol>
                            </ol>
                        </ol>
                    </section>
                    <section>
                        <h4>Сложность сортировки пузырьком</h4>
                        <ul>
                            <li>Внешний цикл выполняет $N - 1$ итераций</li>
                            <li>Общее количество выполнений тела внутреннего цикла равно $$\sum_{i = 1}^{N - 1}N - i,$$ что является суммой арифметической прогрессии от $N - 1$ до $1$</li>
                        </ul> 
                    </section>
                    <section>
                        <h4>Сложность сортировки пузырьком</h4>
                        <ul>
                            <li>Сумма $S$ арифметической прогрессии от $a_1$ до  $a_N$ рассчитывается как $$S = \frac{a_1 + a_N}{2} \cdot N$$</li>
                            <li>Для нашего случая: $$\frac{N - 1 + 1}{2} \cdot (N - 1) = \frac{N}{2} \cdot (N - 1)$$</li>
                        </ul> 
                    </section>
                    <section>
                        <h4>Сложность сортировки пузырьком</h4>
                        <ul>
                            <li>Обратимся к $O$-нотации:</li>
                            $$\frac{N}{2} \cdot (N - 1) = \frac{1}{2}(N^2 - N) = O(N^2)$$
                        </ul> 
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Теоретическая граница сложности</h4>
                        <ul>
                            <li>Чтобы понять, эффективна ли пузырьковая сортировка, необходимо определить некоторую границу наилучшей достижимой сложности всех алгоритмов сортировки</li>
                            <li>Для этого снова воспользуемся деревом решений</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево решений</h4>
                        <ul>
                            <li>Как и алгоритмы поиска, алгоритмы сортировки для определённого числа элементов могут быть представлены в виде деревьев решений</li>
                            <li>Каждый узел такого дерева, кроме листьев – сравнение двух элементов с определёнными индексами</li>
                            <li>Каждый лист такого дерева – ответ в виде одной из перестановок индексов исходной последовательности</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево решений пузырьковой сортировки для трёх элементов</h4>
                        <p>
                            <img src="03/bubble_des_tree.png">
                        </p>
                    </section>
                    <section>
                        <h4>Дерево решений</h4>
                        <ul>
                            <li>Как видно, максимальная высота узла дерева равна количеству сравнений в худшем случае</li>
                            <li>Дерево для пузырьковой сортировки построено неэффективно</li>
                            <li>Как уже было доказано на лекции про поиск, при оптимальном построении дерева его максимальная высота равна $ \lfloor log_2(N) \rfloor$, где $N$ – кол-во листьев</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Граница сложности</h4>
                        <ul>
                            <li>Чтобы получить теоритическую границу лучшей достижимой сложности сортровки, нужно вычислить максимальную высоту узла в оптимальном дереве</li>
                            <li>Количетсво листьев в дереве всегда равно количеству всевозможных решений, что равно количеству перестановок из $N$ элементов и равно $$N!$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Граница сложности</h4>
                        <ul>
                            <li>Таким образом, искомая граница равна $log_2(N!)$</li>
                            <li>Чтобы привести формулу к одной из рассмотренных ранее функций сложности, необходимо воспользоваться формулой Стирлинга: $$N! \approx \sqrt{2\pi N} \left (\frac{N}{e} \right) ^N$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Граница сложности</h4>
                        <p align="left">
                            Логарифмируем полученное выражение:
                        </p>
                        $$log_2 \left(\sqrt{2\pi N} \left (\frac{N}{e} \right) ^N \right) =$$
                        $$ = log_2 \left((2\pi N)^{\frac{1}{2}} \right) + N log_2 \left(\frac{N}{e} \right) = $$
                    </section>
                    <section>
                        <h4>Граница сложности</h4>
                        $$ = \frac{1}{2} log_2(2\pi) + \frac{1}{2} log_2(N) + N log_2(e^{-1}) + N log_2(N) = $$
                    </section>
                    <section>
                        <h4>Граница сложности</h4>
                        $$ = \underbrace {\frac{1}{2} log_2(2\pi)}_{const} + \underbrace{\frac{1}{2}}_{const} log_2(N) + N \underbrace{log_2(e^{-1})}_{const} + N log_2(N) = $$
                    </section>
                    <section>
                        <h4>Граница сложности</h4>
                        $$ = c_1 + c_2 log_2(N) + c_3 N + N log_2(N) = $$
                        $$ = \cancel{c_1} + \cancel{c_2 log_2(N)} + \cancel{c_3 N} + N log_2(N) = $$
                        $$ = O(N log_2(N)) $$
                    </section>
                    <section>
                        <h4>Эффективность пузырьковой сортировки</h4>
                        <ul>
                            <li>Таким образом, можно заключить, что сортировка пузырьком не является оптимальным решением задачи сортировки, т.к. её сложность превосходит по порядку роста наилучшую достижимую</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Сортировка вставками</h4>
                        <ul>
                            <li>Существует ряд более эффективных алгоритмов сортировки</li>
                            <li>Один из таких алгоритмов – сортировка вставками (insertion sort)</li>
                        </ul>
                        <ol>
                            <li>Для $k$ от $2$ до $N$ выполнять:</li>
                            <ol>
                                <li>Среди элементов от $a_1$ до $a_{k - 1}$ найти такой индекс $i$, чтобы $a_{i - 1} &lt; a_k \leqslant a_i$</li>
                                <li>Вставить $a_k$ перед $a_i$</li>
                            </ol>
                        </ol>
                    </section>
                    <section>
                        <h4>Сложность сортировки вставками</h4>
                        <ul>
                            <li>Т.к. цикл в любом случае выполняется $N - 1$ раз, сложность сортировки вставками определяется сложностью поиска нужного индекса</li>
                            <li>Простейший (и классический) способ – воспользоваться линейным поиском</li>
                            <li>В таком случае $N - 1$ операций поиска за $O(N)$ дадут сложность $O(N^2)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Улучшение сортировки вставками</h4>
                        <ul>
                            <li>Рассмотрим алгоритм более подробно</li>
                            <li>Т.к. на каждой итерации очередной элемент вставляется на своё место, последовательность от $a_1$ до $a_{k - 1}$ всегда отсортирована</li>
                            <li>Для поиска в отсортированной последовательности существует более эффективный алгоритм – двоичный поиск, однако изначально он предназначен для поиска существующего элемента</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Применение двоичного поиска</h4>
                        <ul>
                            <li>Если передать алгоритму двоичного поиска элемент, не находящийся в последовательности, он вернёт позицию, на которой можно расположить искомый элемент</li>
                            <li>Есть единственный нюанс – ситуация, когда искомый элемент больше всех имеющихся. Алгоритм не может вернуть значение, большее, чем изначальная правая граница.</li>
                            <li>Таким образом, для данной задачи необходимо модифицировать двоичный поиск, задав правую границу на 1 больше</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Улучшение сортировки вставками</h4>
                        <ul>
                            <li>С использованием двоичного поиска сложность составит $N - 1$ поисков за $O(log_2(N))$, что даёт $$O(Nlog_2(N))$$</li>
                            <li>Такая сложность совпадает с наилучшей достижимой для алгоритма сортировки, а значит, insertion sort – оптимальный алгоритм сортровки</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Проблема сортировки вставками</h4>
                        <ul>
                            <li>Сортировка вставками теоретически является оптимальным алгоритмом</li>
                            <li>Однако на деле её эффективность во многом зависит от того, как хранится последовательность</li>
                            <li>Как мы увидим на следующих лекциях, для некоторых структур данных сама вставка элемента на произвольную позицию – операция, выполняемая со сложностью $O(N)$</li>
                            <li>Для таких структур данных сортировка вставками неэффективна</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Сортировка слиянием</h4>
                        <ul>
                            <li>Рассмотрим другой алгоритм сортировки – сортировку слиянием (merge sort)</li>
                            <li>Для этого сначала введём вспомогательную процедуру слияния (merge)</li>
                            <li>Процедура принимает на вход массив, две половины которого отсортированы, и на выходе выдаёт полностью отсортированный массив</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Разделение</h4>
                        <p>
                            <img src="03/split.png">
                        </p>
                    </section>
                    <section>
                        <h4>Объединение</h4>
                        <p>
                            <img src="03/merge.png">
                        </p>
                    </section>
                    <section>
                        <h4>Алгоритм слияния</h4>
                        <ul>
                            <li>Разделение массива на два при заданных границах $p$, $q$ и $r$ тривиально</li>
                            <li>Далее на каждом шаге слияния производится сравнение наименьших ещё не "влитых" в результат элементов двух подмассивов</li>
                            <li>Алгоритм можно усовершенствовать, введя проверку на то, что все элементы одного подмассива уже "ушли" в результат, в таком случае оставшийся подмассив можно перенести в результат целиком</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Сложность слияния</h4>
                        <ul>
                            <li>Разделение на подмассивы требует $N$ операций – по одной операции копирования на каждый элемент</li>
                            <li>Во время слияния производится не более $2N - 1$ сравнений и $N$ копирований в результирующий массив</li>
                            <li>Таким образом, сложность слияния: $$O(N)$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Сортировка слиянием</h4>
                        <p align="left">
                            <b>merge_sort(a, p, r):</b>
                        </p>
                        <ol>
                            <li>Если $p &lt; r$, выполнить:</li>
                            <ol>
                                <li>Вычислить $q = \lfloor \frac{p + r}{2} \rfloor$</li>
                                <li>Выполнить merge_sort(a, p, q)</li>
                                <li>Выполнить merge_sort(a, q + 1, r)</li>
                                <li>Слить фрагмент массива $a$ от $q$ до $r$ с серединой в $q$</li>
                            </ol>
                        </ol>
                    </section>
                    <section>
                        <h4>Анализ сортировки слиянием</h4>
                        <ul>
                            <li>Рассмотренный алгоритм отличается от всех, что были рассмотрены ранее</li>
                            <li>В нём используется <b>рекурсивный вызов</b> процедуры</li>
                            <li>Таким образом, его сложность можно записать в виде <b>рекуррентного соотношения</b>:</li>
                        </ul>
                        $$
                            \begin{equation*}
                                T(N) = 
                                \begin{cases}
                                    c, при\ N = 1\\
                                    2T(\frac{N}{2}) + cN, при\ N &gt; 1
                                \end{cases}
                            \end{equation*}
                        $$
                    </section>
                    <section>
                        <h4>Анализ сортировки слиянием</h4>
                        <ul>
                            <li>$c$ в данном выражении означает некоторое константное время</li>
                            <li>Чтобы получить вычислительноую сложность в $O$-нотации, необходимо решить рекуррентное соотношение</li>
                            <li>Подробно способы решения будут рассмотрены на следующих лекциях</li>
                            <li>В данный момент ограничимся лишь одним из них – деревом рекурсии</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево рекурсии</h4>
                        <p>
                            <img src="03/rec_tree.png" height="70%" width="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Анализ сортировки слиянием</h4>
                        <ul>
                            <li>На каждом уровне рекурсии выполняется $cN$ операций и производится ещё два рекурсивных вызова для $\frac{N}{2}$</li>
                            <li>Таким образом, т.к. высота дерева равна $\lfloor log_2(N) \rfloor$, всего понадобится $cNlog_2(N) + cN$ операций</li>
                            <li>Тогда результирующая сложность составит $$O(Nlog_2(N))$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ сортировки слиянием</h4>
                        <ul>
                            <li>Данный алгоритм ялвяется оптимальным с точки зрения времени выполнения</li>
                            <li>Однако для его работы требуется $\Theta(N)$ дополнительной памяти на хранение подмассивов</li>
                            <li>На следующих лекциях будут рассмотрены алгоритмы сортировки, не требующие дополнительной памяти</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Разделы 2.3 и 8.1. – Основная книга нашего курса.</li>
                            <li><b>RU</b> <a href='https://mk.cs.msu.ru/images/c/c4/KNIGA1.pdf'>В.Б. Алексеев. Введение в теорию сложности алгоритмов.</a> Раздел 1.2 – Математическое обоснование рассказанного</li>
                            <li><b>EN</b> <a href='https://visualgo.net/en/sorting'>Управляемая визуализация многих сортировок</a></li>                        
                            <li><b>EN</b> <a href='https://opendsa-server.cs.vt.edu/OpenDSA/Books/Everything/html/Mergesort.html'>Визуализация сортировки слиянием</a></li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="5">
                            <li><b>EN</b> <a href='https://youtu.be/XaqR3G_NVoo'>Танцевальная визуализация сортировки слиянием</a></li>
                            <li><b>EN</b> <a href='https://youtu.be/ROalU379l3U'>Танцевальная визуализация сортировки вставками</a></li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>