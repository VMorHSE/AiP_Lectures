<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">
        <link rel="stylesheet" href="">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
        <style>
            .reveal .slides section .fragment.step-fade-in-then-out {
                opacity: 0;
                display: none; }
            .reveal .slides section .fragment.step-fade-in-then-out.current-fragment {
                opacity: 1;
                display: inline; }
            .reveal .slides section .fragment.step-fade-in {
                opacity: 0;
                display: none; }
            .reveal .slides section .fragment.step-fade-in.current-fragment {
                opacity: 1;
                display: inline; }
            .reveal .slides section .fragment.step-fade-out {
                opacity: 0;
                display: none; }
            .reveal .slides section .fragment.step-fade-out.current-fragment {
                opacity: 1;
                display: inline; }
        </style>

        <style>
            .two-columns {
                display: flex;
                justify-content: space-between;
                gap: 40px;
            }
            .two-columns > div {
                flex: 1;
                text-align: left;
            }
        </style>
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Конечные автоматы</h4>
                </section>
                <section>
                    <section>
                        <h4>Обработка последовательностей</h4>
                        <ul>
                            <li>Частой задачей в вычислительной технике является обработка некоторых последовательностей</li>
                            <li>Мы уже рассмотрели сортировку, поиск и т.п.</li>
                            <li>Но последовательности могут содержать не только неокторые сравнимые объекты, но также, например, действия пользователя</li>
                            <li>В таких случаях важно понять, является ли заданная последовательность &laquo;действий&raquo; <b>корректной</b> для конкретного исполнителя</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <ul>
                            <li>Пусть у нас есть примитивный калькулятор</li>
                            <li>Он может работать только с натуральными числами и поддерживает только операции $+$, $-$, $*$, $/$</li>
                            <li>Для получения решения пользователь должен ввести $=$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Корректность ввода</h4>
                        <ul>
                            <li>Для такого калькулятора легко определить, является ли тот или иной ввод пользователя корректным</li>
                            <li>Например, "$11+25=$" — корректное выражение, "$123/1025=$" — тоже</li>
                            <li>Тогда как "$11=$", "$25++2$", "$+/33$" и "$=371+$" очевидно некорректны</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Реализация</h4>
                        <ul>
                            <li>Для программной реализации проверки корректности (например, в качестве предварительного этапа перед расчётом) необходимо ответить на два вопроса</li>
                            <li>Во-первых, как реализовать проверку <b>всех</b> допустимых выражений, если их, очевидно, бесконечное множество?</li>
                            <li>Во-вторых, как описать множество всех корректных выражений?</li>
                            <li>Далее мы увидим, что эти два вопроса эквивалентны</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Решение</h4>
                        <ul>
                            <li>Ответом на оба вопроса являются <b>конечные автоматы</b></li>
                            <li>Конечный автомат — особый способ организации алгоритма вычислений</li>
                            <li>Во-первых, конечный автомат читает выражение символ за символом</li>
                            <li>Во-вторых, на каждом шаге работы автомат <b>ожидает</b> ввода некоторого корректного символа</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <ul>
                            <li>К примеру, если было прочитано $115$, ожидается знак арифметической операции или ещё одна цифра</li>
                            <li>Если же было прочитано $1+2$, ожидается $=$ или ещё одна цифра</li>
                            <li>Если автомат читает &laquo;неожиданный&raquo; символ, констатируется некорректность выражения</li>
                            <li>Например, если прочитано $33$, автомат &laquo;не ожидает&raquo; $=$ в качестве следующего символа</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Задача построения автомата</h4>
                        <ul>
                            <li>Остаётся понять, как определить набор символов, ожидаемых на каждом шаге</li>
                            <li>Очевидно, этот набор зависит от символов, прочитанных на предыдущих шагах</li>
                            <li>Однаком мы не можем, например, построить таблицу всех возможных прочитанных последовательностей, т.к. их бесконечно много</li>
                            <li>Ограничимся последним прочитанным символом</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Задача построения автомата</h4>
                        <ul>
                            <li>Однако такое ограничение не позволяет нам отличать, например, ситуации, где прочитано $125$ и $125+55$</li>
                            <li>Чтобы учесть подобные различия, вводится понятие <b>состояния</b> конечного автомата</li>
                            <li>Тогда набор &laquo;ожидаемых&raquo; символов определяется последним прочитанным символом и текущим состоянием автомата </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Смена состояний</h4>
                        <ul>
                            <li>Изначально автомат находится в <b>начальном</b> состоянии</li>
                            <li>Прочитав &laquo;ожидаемый&raquo; символ, автомат переходит в другое состояние (возможно, в то же самое) в зависимовтси от символа</li>
                            <li>Для каждого состояния определяется набор ожидаемых символов, а также следующее состояние, в которое перейдёт автомат, прочитав каждый из символов</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <ul>
                            <li>Например, автомат для нашего калькулятора в начальном состоянии будет ожидать цифру $0..9$</li>
                            <li>Прочитав цифру, автомат перейдёт в новое состояние</li>
                            <li>В новом состоянии автомат будет ожидать цифру $0..9$ или арифметический оператор</li>
                            <li>Прочитав цифру, автомат останется в том же состоянии, а прочитав оператор, перейдёт в новое и т.д.</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Графическое представление конечного автомата</h4>
                        <ul>
                            <li>Конечные автоматы принято изображать графически</li>
                            <li>При этом каждое из состояний обозначается кругом</li>
                            <li>Переходы состояний обозначаются стрелками</li>
                            <li>А символы, при чтении которых производятся эти переходы, пишутся над стрелками</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Конечный автомат для калькулятора</h4>
                        <p>
                            <img src="09/calc_fsm.png">
                        </p>
                    </section>
                    <section>
                        <h4>Состояния</h4>
                        <ul>
                            <li>Состояние $q_0$ называется <b>начальным</b>, это точка входа</li>
                            <li>Состояние $q_3$ — <b>конечное</b> или <b>принимающее</b></li>
                            <li>Когда автомат достигает конечного состояния, считав при этом всю строку, это значит, что строка <b>принята</b></li>
                        </ul>
                    </section>
                    <section>
                        <h4>Замечание</h4>
                        <ul>
                            <li>Автомат не обязательно останавливает работу при достижении конечного состояния</li>
                            <li>Из конечного состояния также могут быть переходы в другие состояния</li>
                            <li>Главное — быть в конечном состоянии, когда строка закончится</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Ещё один пример</h4>
                        <ul>
                            <li>Чтобы закрепить знания о графическом представлении автоматов, построим ещё один</li>
                            <li>На этот раз автомат должен принимать все арифметические равенства с целыми числами (не проверяя верность)</li>
                            <li>Например, $-22 + 11 = -555$ должно быть принято</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Конечный автомат для целочисленных равенств</h4>
                        <p>
                            <img src="09/int_eq_fsm.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Формализация</h4>
                        <p align="left">Теперь дадим формальное определение детерминированного конечного автомата $M$. Он состоит из:</p>
                        <ul>
                            <li>Множества всех состояний $Q$</li>
                            <li>Начального состояния $q_0 \in Q$</li>
                            <li>Множества конечных (допускающих) состояний $A \subseteq Q$</li>
                            <li>Алфавита символов входной строки $\Sigma$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Функция переходов</h4>
                        <ul>
                            <li>Наконец, последней и наиболее интересной составляющей конечного автоамта является функция переходов $\delta$</li>
                            <li>Именно она определяет, какие символы &laquo;ожидаются&raquo; в каждом из состояний, и в какое состояние автомат переходит при чтении символа</li>
                            $$\delta: Q \times \Sigma \rightarrow Q$$
                        </ul>
                    </section>
                    <section>
                        <h4>Функция переходов</h4>
                        <ul>
                            <li>Функция переходов принимает текущее состояние и текущий считанный символ</li>
                            <li>Возвращает она состояние, в которое автомат должен перейти</li>
                            <li>Задаётся функция переходов перечислением её значений для всех допустимых аргументов</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Пример функции переходов</h3>
                        <p align="left">Приведём пример функции переходов для калькулятора</p>
                        <p>$\delta(q_0, 0..9) = q_1$</p>
                        <p>$\delta(q_1, 0..9) = q_1$</p>
                        <p>$\delta(q_1, \{+, -, *, /\}) = q_2$</p>
                        <p>$\delta(q_2, 0..9) = q_2$</p>
                        <p>$\delta(q_2, =) = q_3$</p>
                    </section>
                    <section>
                        <h3>Замечание</h3>
                        <ul>
                            <li>Как в этом примере, так и в графическом, мы допустили важное сокращение</li>
                            <li>Мы определили функции перехода сразу от множества входных символов (например, $0..9$)</li>
                            <li>В действительности, чтобы правильно описать автомат, нам нужно определить функцию для каждого символа и состояния по отдельности</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Табличное представление</h3>
                        <table>
                            <tr>
                                <th>$q_i \backslash \Sigma_j$</th> <th>$0$</th> <th>$1$</th> <th>$2$</th> <th>$3$</th> <th>$...$</th> <th>$+$</th> <th>$-$</th> <th>$*$</th> <th>$/$</th> <th>$=$</th>
                            </tr>
                            <tr>
                                <th>$q_0$</th> <td>$q_1$</td> <td>$q_1$</td> <td>$q_1$</td> <td>$q_1$</td> <td>$...$</td> <td>-</td> <td>-</td> <td>-</td> <td>-</td> <td>-</td>
                            </tr>
                            <tr>
                                <th>$q_1$</th> <td>$q_1$</td> <td>$q_1$</td> <td>$q_1$</td> <td>$q_1$</td> <td>$...$</td> <td>$q_2$</td> <td>$q_2$</td> <td>$q_2$</td> <td>$q_2$</td> <td>-</td>
                            </tr>
                            <tr>
                                <th>$q_2$</th> <td>$q_2$</td> <td>$q_2$</td> <td>$q_2$</td> <td>$q_2$</td> <td>$...$</td> <td>-</td> <td>-</td> <td>-</td> <td>-</td> <td>$q_3$</td>
                            </tr>
                        </table>
                    </section>
                    <section>
                        <h3>Определение</h3>
                        <ul>
                            <li>Итак, детерминированный конечный автомат представлен следующей пятёркой:</li>
                            $$M = (Q, q_0, A, \Sigma, \delta)$$
                            <li>Автомат начинает работу в начальном состоянии и работает, пока не закончится строка или не встретится &laquo;неожиданный&raquo; символ</li>
                            <li>Если в конце работы автомата он находится в конечном состоянии, строка принимается</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Конфигурация автомата</h3>
                        <ul>
                            <li>Дадим более формальное определение корректной и некорректной строке для данного автомата</li>
                            <li>Для этого сначала необходимо ввести понятие <b>конфигурации</b> автомата</li>
                            <li>Конфигурация — пара $C = (q, w)$ из текущего состояния $q$ и текущего непрочитанного остатка строки $w$</li>
                            <li>Конфигурация автомата полностью описывает конкретный этап его работы</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Выводимость</h3>
                        <ul>
                            <li>Теперь введём отношение <b>выводимости</b> на данном автомате $M$</li>
                            <li>Конфигурация $C'$ выводима (достижима) из конфигурации $C$, если, находясь в конфигурации $C$, автомат может сделать ряд шагов и прийти в конфигурацию $C'$</li>
                            <li>Выводимость в автомате $M$ обозначается как</li>
                            $$C \vdash_M C'$$
                        </ul>
                    </section>
                    <section>
                        <h3>Определение корректной строки</h3>
                        <ul>
                            <li>Пусть даны строка $w$ и автомат $M$</li>
                            <li>Строка $w$ корректна (принимается<br>автоматом $M$), если:</li>
                            $$(q_0, w) \vdash_M (q_n, \epsilon), q_n \in A,$$
                            <li>где $\epsilon$ — пустая строка</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Формальные языки</h3>
                        <ul>
                            <li>Пусть даны алфавит $\Sigma$ и автомат $M$</li>
                            <li>Определим множество всех строк (любой длины), которые можно составить из символов алфавита $\Sigma$ как $\Sigma^*$</li>
                            <li>Тогда $L \subseteq \Sigma^*$ называется <b>языком</b>, определяемым автоматом $M$, если:</li>
                            $$\forall w \in L, q_n \in A: (q_0, w) \vdash_M (q_n, \epsilon)$$
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Применение</h3>
                        <ul>
                            <li>Концепция конечного автомата (или машины состояний — state machine) нашла широкое применение в вычислительной технике</li>
                            <li>Мы рассмотрим применение конечного автомата на уже знакомой задаче поиска подстроки в строке</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Поиск подстроки</h3>
                        <ul>
                            <li>Идея состоит в построении конечного автомата по подстроке и обработке строки с помощью этого автомата</li>
                            <li>Т.к. автомат читает по символу на каждом шаге и никогда не возвращается назад, сложность этапа поиска — $\Theta(N)$</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Наивное решение</h3>
                        <ul>
                            <li>Осталось разработать алгоритм, который будет эффективно строить конечный автомат из искомой подстроки</li>
                            <li>Простейшим решением было бы построить автомат с одним переходом на каждый символ подстроки</li>
                            <li>На рисунке пример для подстроки $abc$</li>
                        </ul>
                        <p>
                            <img src="09/substring_simple_fsm.png">
                        </p>
                    </section>
                    <section>
                        <h3>Недостатки</h3>
                        <ul>
                            <li>Применять такой автомат можно, передавая ему на каждом шаге строку, укороченную на $1$ символ</li>
                            <li>Если автомат дойдёт до конечного состояния, подстрока найдена</li>
                            <li>Однако сложность такого решения равна сложности простого скользящего окна с шагом $1$</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Идея оптимизации</h3>
                        <ul>
                            <li>Чтобы получить лучшую сложность, нужно снова выработать правила сдвигов</li>
                            <li>Для конечного автомата сдвиг будет выражен в переходе к одному из предыдущих состояний</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Оптимизация</h3>
                        <ul>
                            <li>Представим, что, используя простейший ДКА, мы нашли очередное вхождение подстроки, т.е. автомат находится в конечном состоянии</li>
                            <li>К какому состоянию нужно перейти, чтобы не перезапускать работу автомата, а продолжить обработку строки?</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Пример</h3>
                        <p>
                            <img src="09/substring_simple_match.png">
                        </p>
                    </section>
                    <section>
                        <h3>Решение</h3>
                        <ul>
                            <li>В данном случае автомат, очевидно, должен перейти в состояние, соответствующее считанной букве</li>
                            <li>Результирующий автомат будет выглядеть так</li>
                        </ul>
                        <p>
                            <img src="09/substring_simple_mod_1.png">
                        </p>
                    </section>
                    <section>
                        <h3>Дальнейшая оптимизация</h3>
                        <ul>
                            <li>Во всех случаях, когда в строке встречается буква, которой нет в подстроке, автомат должен переходить в начальное состояние</li>
                            <li>Для экономии места это не будет отражаться на рисунках</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Усложнение</h3>
                        <ul>
                            <li>Рассмотрим более сложную ситуацию</li>
                            <li>Пусть есть строка $ababab...$ и подстрока $ababc$</li>
                            <li>Куда нужно совершить переход при чтении следующего символа на рисунке?</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Какой переход верен?</h3>
                        <p>
                            <img src="09/substring_simple_question.png">
                        </p>
                    </section>
                    <section>
                        <h3>Решение</h3>
                        <ul>
                            <li>В состояние $q_1$ перейти нельзя, т.к. пропустим совпадение, если следующий символ строки равен $c$</li>
                            <li>Попробуем обобщить данную ситуацию</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Обобщение</h3>
                        <ul>
                            <li>Пусть $k$ символов строки совпали с символами подстроки</li>
                            <li>Тогда мы находимся в состоянии $q_k$ и на вход автомата идёт следующий символ строки $t_i$</li>
                            <li>Нам нужно &laquo;сдвинуть&raquo; подстроку так, чтобы длиннейший её префикс совпадал со строкой $s_{0..k}t_i$</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Вычисление сдвига</h3>
                        <ul>
                            <li>В терминах конечного автомата это аналогично переходу к состоянию $q_i$, где $j$ — длина такого префикса</li>
                            <li>Для вычисления длин подобных префиксов существует суффикс-функция $\sigma_s: \Sigma^* \rightarrow \mathbb{N}_0$</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Суффикс-функция</h3>
                        <ul>
                            <li>Суффикс функция похожа на остальные функции предобработки строк, которые мы уже рассматривали</li>
                            <li>Для каждой строки $x$ суффикс-функция возвращает длину наибольшего префикса подстроки $s$, являющегося суффиксом этой строки</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Вычисление</h3>
                        <ul>
                            <li>В нашем случае строки $x$ строятся по форме $s_{0..k}t_i$, где $s_{0..k}$ — префикс подстроки $s$ длины $k$, а $t_i$ — очередной символ подстроки $t$</li>
                            <li>Тогда для быстрого получения значений суффикс-функции нужно хранить таблицу размером $m |\Sigma|$</li>
                            <li>Построить такую таблицу можно с использованием префикс- или $Z$-функции</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Результат</h3>
                        <p align="left">Таким образом, функция перехода конечного автомата для поиска подстроки в строке дополняется следующим образом</p>
                        $$\delta(q_j, t_i) = q_{\sigma_s(s_{0..j}t_i)}$$
                    </section>
                    <section>
                        <h3>Результат</h3>
                        <p align="left">Тогда полный набор значений функции перехода будет строиться по следующему правилу:</p>
                        $$\forall t_i \in \Sigma, j = \overline{0..M}: \delta(q_j, t_i) = q_{\sigma_s(s_{0..j}t_i)}$$
                        $$\forall j = \overline{1..M}: \delta(q_{j-1}, s_j) = q_j$$
                    </section>
                    <section>
                        <h3>Результат</h3>
                        <p align="left">Результирующий конечный автомат с данной функцией перехода будет выглядеть следующим образом (переходы в состояние $q_0$ не изображены)</p>
                        <p>
                            <img src="09/substring_res.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Другие применения конечных автоматов</h3>
                        <ul>
                            <li>Как уже было отмечено, конечные автоматы имеют множество применений</li>
                            <li>Ещё одно из них — <b>регулярные выражения</b></li>
                            <li>В действительности для регулярных выражений строятся более сложные конечные автоматы (недетерминированные)</li>
                            <li>Однако в данной лекции мы ограничимся упрощённым вариантом</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Упрощение</h3>
                        <ul>
                            <li>Мы рассмотрим упрощённый аналог регулярных выражений — глобы (globs)</li>
                            <li>Это специальные выражения, которые используются командными оболочками (например, bash) для выполнения команд над группами файлов</li>
                            <li>К примеру, чтобы скопировать все текстовые файлы в папку folder, в bash можно написать</li>
                        </ul>
                        <pre><code data-trim class="bash">
                            cp *.txt folder
                        </code></pre>
                    </section>
                    <section>
                        <h3>Обработка глобов</h3>
                        <ul>
                            <li>В действительности при обработке глобов ДКА не используются</li>
                            <li>Однако теоретически нет никаких препятствий такой реализации</li>
                            <li>Символ $*$ означает любое количество любых символов ($0$ или больше)</li>
                            <li>Символ $?$ означает ровно один любой символ</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Пример</h3>
                        <p align="left">Попробуем построить конечный автомат, соответствующий выражению <code data-trim class="bash">*.t?t</code></p>
                        <p>
                            <img src="09/glob_match_simple.png">
                        </p>
                    </section>
                    <section>
                        <h3>Обсуждение</h3>
                        <ul>
                            <li>Наш автомат примет строки <code data-trim class="bash">file.txt</code>, <code data-trim class="bash">aaa.tst</code>, <code data-trim class="bash">0123.tat</code> и т.д.</li>
                            <li>Однако этой функциональности недостаточно</li>
                            <li>Выражение <code data-trim class="bash">*.t?t</code> соответствует также строкам <code data-trim class="bash">file.tat.tot.txt</code>, <code data-trim class="bash">abc.tbt.tct</code> и т.п.</li>
                            <li>Но наш автомат не принимает такие строки</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Модификация</h3>
                        <p align="left">Модифицируем наш автомат, чтобы он корректно принимал все строки, соответствующие выражению <code data-trim class="bash">*.t?t</code></p>
                        <p>
                            <img src="09/glob_match_mod.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Раздел 32.3. – Основная книга нашего курса.</li>
                            <li><b>RU</b> А. Ахо, Дж. Ульман. Теория синтаксического анализа, перевода и компиляции. — Очень подробный разбор с математическими выводами.</li>
                            <li><b>EN</b> <a href='https://swtch.com/~rsc/regexp/regexp1.html'>Статья</a> о реализации регулярных выражений в различных ЯП</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="4">
                            <li><b>EN</b> <a href='https://magjac.com/graphviz-visual-editor/?dot=digraph%20finite_state_machine%20%7B%0A%09fontname%3D%22Helvetica%2CArial%2Csans-serif%22%0A%09node%20%5Bfontname%3D%22Helvetica%2CArial%2Csans-serif%22%5D%0A%09edge%20%5Bfontname%3D%22Helvetica%2CArial%2Csans-serif%22%5D%0A%09rankdir%3DLR%3B%0A%09node%20%5Bshape%20%3D%20doublecircle%5D%3B%20q5%3B%0A%09node%20%5Bshape%20%3D%20circle%5D%3B%0A%09%0A%20%20%20%20source%20%5Blabel%3D%22%22%2C%20shape%3Dnone%2C%20height%3D0%2C%20width%3D0%2C%20style%3Dinvis%5D%3B%0A%09%0A%09source%20-%3E%20q0%3B%0A%09q0%20-%3E%20q1%20%5Blabel%20%3D%20%22a%22%5D%3B%0A%09q1%20-%3E%20q2%20%5Blabel%20%3D%20%22b%22%5D%3B%0A%09q2%20-%3E%20q3%20%5Blabel%20%3D%20%22a%22%5D%3B%0A%09q3%20-%3E%20q4%20%5Blabel%20%3D%20%22b%22%5D%3B%0A%09q4%20-%3E%20q5%20%5Blabel%20%3D%20%22c%22%5D%3B%0A%09q4%20-%3E%20q3%20%5Blabel%20%3D%20%22a%22%2C%20constraint%20%3D%20false%5D%3B%0A%09q5%20-%3E%20q1%20%5Blabel%20%3D%20%22a%22%2C%20constraint%20%3D%20false%5D%3B%0A%09q3%20-%3E%20q1%20%5Blabel%20%3D%20%22a%22%2C%20constraint%20%3D%20false%5D%3B%0A%09q1%20-%3E%20q1%20%5Blabel%20%3D%20%22a%22%2C%20constraint%20%3D%20false%5D%3B%0A%7D'>Пример</a> конечного автомата с лекции, доступный для изменения</li>
                            <li><b>EN</b> <a href='https://magjac.com/graphviz-visual-editor/?dot=digraph%20finite_state_machine%20%7B%0D%0A%09fontname%3D%22Helvetica%2CArial%2Csans-serif%22%0D%0A%09node%20%5Bfontname%3D%22Helvetica%2CArial%2Csans-serif%22%5D%0D%0A%09edge%20%5Bfontname%3D%22Helvetica%2CArial%2Csans-serif%22%5D%0D%0A%09rankdir%3DLR%3B%0D%0A%09node%20%5Bshape%20%3D%20doublecircle%5D%3B%20q4%3B%0D%0A%09node%20%5Bshape%20%3D%20circle%5D%3B%0D%0A%09%0D%0A%09source%20%5Blabel%3D%22%22%2C%20shape%3Dnone%2C%20height%3D0%2C%20width%3D0%2C%20style%3Dinvis%5D%3B%0D%0A%09source%20-%3E%20q0%0D%0A%09q0%20-%3E%20q1%20%5Blabel%20%3D%20%22.%22%20fontsize%3D60.0%20fontname%3D%22Times-Roman%22%5D%3B%0D%0A%09q0%20-%3E%20q0%20%5Blabel%20%3D%20%22%26Sigma%3B%5C%5C%7B.%7D%22%20fontsize%3D24.0%20fontname%3D%22Times-Roman%22%5D%3B%0D%0A%09q1%20-%3E%20q2%20%5Blabel%20%3D%20%22t%22%20fontsize%3D24.0%20fontname%3D%22Times-Roman%22%5D%3B%0D%0A%09q2%20-%3E%20q3%20%5Blabel%20%3D%20%22%26Sigma%3B%22%20fontsize%3D24.0%20fontname%3D%22Times-Roman%22%5D%3B%0D%0A%09q3%20-%3E%20q4%20%5Blabel%20%3D%20%22t%22%20fontsize%3D24.0%20fontname%3D%22Times-Roman%22%20constraint%3Dfalse%2C%5D%3B%0D%0A%09%0D%0A%09q1%20-%3E%20q0%20%5Blabel%20%3D%20%22%26Sigma%3B%5C%5C%7Bt%7D%22%20fontsize%3D24.0%20fontname%3D%22Times-Roman%22%5D%3B%0D%0A%09q3%20-%3E%20q0%20%5Blabel%20%3D%20%22%26Sigma%3B%5C%5C%7Bt%7D%22%20fontsize%3D24.0%20fontname%3D%22Times-Roman%22%5D%3B%0D%0A%09q4%20-%3E%20q0%20%5Blabel%20%3D%20%22%26Sigma%3B%22%20fontsize%3D24.0%20fontname%3D%22Times-Roman%22%20constraint%3Dfalse%5D%3B%0D%0A%7D'>Пример</a> другого конечного автомата с лекции, доступный для изменения</li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>