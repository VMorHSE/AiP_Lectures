<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Динамическое програмиирование и жадные алгоритмы</h4>
                </section>
                <section>
                    <section>
                        <h4>Числа Фибоначчи</h4>
                        <ul>
                            <li>Числа Фибоначчи – последовательность, которая рекурсивно задаётся следующей формулой: $$F_1 = 1\\F_2 = 1\\F_i = F_{i - 1} + F_{i - 2}$$</li>
                            <li>На следующем слайде представлен код, вычисляющий $n$-ное число Фибоначчи напрямую по формуле</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Код простейшей программы</h4>
                        <pre><code data-trim class="python">
                            def fib(n):
                                if n == 1 or n == 2:
                                    return 1
                                return fib(n - 1) + fib(n - 2)
                        </code></pre>
                        <p align="left">Построим дерево рекурсии для данной функции с $n = 6$</p>
                    </section>
                    <section>
                        <h4>Дерево рекурсии</h4>
                        <p>
                            <img src="05/fib_rec_tree.png">
                        </p>
                    </section>
                    <section>
                        <h4>Неэффективность алгоритма</h4>
                        <ul>
                            <li>По дереву рекурсии можно видеть, что такой алгоритм вычисления чисел Фибоначчи крайне неэффективен ($O(2^N)$)</li>
                            <li>Основная причина неэффективности данного алгоритма заключается в том, что одни и те же подзадачи решаются множество раз, например, $F(0)$ вычисляется $5$ раз</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Улучшение алгоритма</h4>
                        <ul>
                            <li>Чтобы несколько раз не решать одни и те же задачи, заведём таблицу, в которую будем записывать решения каждой из задач</li>
                            <li>Тогда, если решение уже есть в таблице, оно не будет вычисляться снова</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Код простейшей программы</h4>
                        <pre><code data-trim class="python">
                            def fib_memoized(n, table):
                                if n not in table:
                                    table[n] = fib_memoized(n - 1, table) + 
                                        fib_memoized(n - 2, table)
                                return table[n]
                        </code></pre>
                        <p align="left">Построим дерево рекурсии для данной функции с $n = 6$</p>
                    </section>
                    <section>
                        <h4>Дерево рекурсии</h4>
                        <p>
                            <img src="05/fib_memoized_rec_tree.png">
                        </p>
                    </section>
                    <section>
                        <h4>Анализ дерева</h4>
                        <ul>
                            <li>Как видно, алгоритм стал работать гораздо более эффективно (за $O(N)$)</li>
                            <li>Запоминание решений подзадач, которые понадобятся в дальнейшем, называется <b>мемоизация</b> (memoization)</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Восходящий и нисходящий подходы</h4>
                        <ul>
                            <li>В представленном улучшении алгоритма мы воспользовались <b>нисходящим подходом</b> – начали решение с большой задачи и "спускались" к более мелким подзадачам</li>
                            <li>При применении с мемоизацией такой подход достаточно эффективен, однако это не предел</li>
                            <li>Если решать задачи от меньшей к большей, можно вообще избавиться от рекурсии. Это <b>восходящий поход</b>.</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Код с восходящим подходом</h4>
                        <pre><code data-trim class="python">
                            def fib_bottom_up(n):
                                table = [0, 1, 1]
                                for i in range(3, n + 1):
                                    table.append(table[i - 1] + table[i - 2])
                                return table[-1]
                        </code></pre>
                    </section>
                    <section>
                        <h4>Преимущества восходящего подхода</h4>
                        <ul>
                            <li>Восходящий подход не переводит алгоритм в новый класс сложности, задача всё так же решается за $O(N)$</li>
                            <li>Однако теперь производится меньше затрат на рекурсивные вызовы, что позволяет понизить константный множитель</li>
                            <li>Задачу поиска числа Фибоначчи можно решить ещё более эффективным итерационным алгоритмом без излишних затрат памяти, но это решение за рамками данной лекции</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Подходящие задачи</h4>
                        <ul>
                            <li>Чтобы решать задачи методом динамического программирования, нужно уметь отличать те из них, для которых данный метод подходит</li>
                            <li>На примере вычисления факториала мы уже увидели одну отличительную черту таких задач, а именно – <b>перекрывающиеся подзадачи</b></li>
                            <li>Это такие подзадачи, решение которых требуется несколько раз для решения более объёмных задач</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Подходящие задачи</h4>
                        <ul>
                            <li>Чтобы описать второе ключевое свойство задач, решаемых с помощью динамического программирования, необходимо ввести некоторые определения</li>
                            <li>Как правило, динамические алгоритмы применяются в <b>задачах оптимизации</b> – таких задачах, где есть множество решений, и необходимо выбрать наиболее эффективное из них – оптимальное решение</li>
                            <li>Чтобы ввести свойство, сначала приведём пример</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Дискретная задача о рюкзаке</h4>
                        <p align="left">
                            Дискретная задача о рюкзаке (0-1 knapsack problem) формулируется следующим образом:
                        </p>
                        <ul>
                            <li>Во время ограбления магазина вор обнаружил $n$ предметов</li>
                            <li>$i$-ый предмет стоит $v_i$ и весит $w_i$</li>
                            <li>У вора есть рюкзак грузоподъёмностью $W$</li>
                            <li>$v_i, w_i, W \in \N$</li>
                            <li>Как набрать предметы на наибольшую суммарную стоимость?</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Построение решения</h4>
                        <ul>
                            <li>Чтобы решить эту задачу, нужно для каждого предмета принять решение, добавлять ли его в рюкзак (этим обосновано "0-1" в англоязычном названии)</li>
                            <li>Чтобы для $i$ предметов и ёмкости $j$ принять такое решение, нужно проверить, что даст большую стоимость и при этом поместится в рюкзак: лучшая комбинация предметов, включающая $i$-ый предмет, или лучшая комбинация без этого предмета</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Оптимальная подструктура</h4>
                        <ul>
                            <li>В формулировании решения можно заметить важный момент: чтобы найти лучшую комбинацию для $i$ предметов и вместимости $j$, нам нужно найти лучшие комбинации для<br>$i' &lt; i$ и $j' &lt; j$</li>
                            <li>То есть оптимальное решение задачи включает оптимальные решения подзадач</li>
                            <li>В таком случае говорят, что задача образует <b>оптимальную подструктуру</b></li>
                            <li>Это второе свойство задач на динамическое программирование</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Построение решения</h4>
                        <ul>
                            <li>Продолжим задачу о рюкзаке</li>
                            <li>Пусть $V[i, j]$ – максимальная стоимость подмножества из $i$ предметов для вместимости $j$</li>
                            <li>Чтобы её получить, нам нужно, во-первых, получить максимальную стоимость подмножества без $i$-ого предмета – это $i - 1$ предметов при той же вместимости:<br>$V[i - 1, j]$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Построение решения</h4>
                        <ul>
                            <li>Во-вторых, нам нужно получить максимальную стоимость подмножества, обязательно включающего $i$-ый предмет</li>
                            <li>Стоимость такого подмножества равна стоимости самого $i$-ого предмета в сумме с максимальной стоимостью подмножества без <nobr>$i$-ого</nobr> предмета при вместимости $j - w_i$:<br>$v_i + V[i - 1, j - w_i]$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Построение решения</h4>
                        <ul>
                            <li>Таким образом, получим следующее выражение для максимальной стоимости подмножества из $i$ предметов при вместимости $j$:$$V[i, j] = max(V[i - 1, j], v_i + V[i - 1, j - w_i])$$</li>
                            <li>Однако, если $i$-ый предмет не вмещается в рюкзак (т.е. $j - w_i &lt; 0$), в качестве решения берётся максимальная стоимость для предметов без $i$-ого</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Построение решения</h4>
                        <p align="left">
                            $$
                            \begin{equation*}
                                V[i, j] = 
                                \begin{cases}
                                    V[i - 1, j], если\ j - w_i &lt; 0,\\
                                    max(V[i - 1, j], v_i + V[i - 1, j - w_i]).
                                \end{cases}
                            \end{equation*}
                            $$
                        </p>
                    </section>
                    <section>
                        <h4>Решение</h4>
                        <ul>
                            <li>Теперь можно построить решение, используя таблицу размером $n \times W$ и постепенно заполняя её. Его сложность – $O(nW)$.</li>
                            <li>Примечательно, что нисходящих подход здесь подойдёт лучше, чем восходящий, т.к. для решение глобальной задачи требуется решение только некоторых, а не всех возможных, подзадач</li>
                            <li>В качестве базовых случаев рекурсии можно взять ситуации, когда $i$ или $j$ равны $0$. Результатом такого вызова должен быть $0$.</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Задача о выборе процессов</h4>
                        <p align="left">
                            Сформулируем ещё одну задачу:
                        </p>
                        <ul>
                            <li>Пусть есть однопроцессорный компьютер</li>
                            <li>Также есть множество процессов $S = \{a_1, a_2, ..., a_N\}$, готовых для выполнения</li>
                            <li>$i$-ый процесс должен работать в течение интервала времени $[s_i, f_i)$</li>
                            <li>Задача: выбрать максимальное подмножество непересекающихся по времени процессов</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <p align="left">
                            Рассмотрим пример входных данных для задачи, состоящий из $11$ процессов, отсортированных по времени завершения
                        </p>
                        <table>
                            <tr>
                                <th>$i$</th>
                                <td>$1$</td>
                                <td>$2$</td>
                                <td>$3$</td>
                                <td>$4$</td>
                                <td>$5$</td>
                                <td>$6$</td>
                                <td>$7$</td>
                                <td>$8$</td>                      
                                <td>$9$</td>
                                <td>$10$</td>
                                <td>$11$</td>
                            </tr>
                            <tr>
                                <th>$s_i$</th>
                                <td>$1$</td>
                                <td>$3$</td>
                                <td>$0$</td>
                                <td>$5$</td>
                                <td>$3$</td>
                                <td>$5$</td>
                                <td>$6$</td>
                                <td>$8$</td>                      
                                <td>$8$</td>
                                <td>$2$</td>
                                <td>$12$</td>
                            </tr>
                            <tr>
                                <th>$f_i$</th>
                                <td>$4$</td>
                                <td>$5$</td>
                                <td>$6$</td>
                                <td>$7$</td>
                                <td>$9$</td>
                                <td>$9$</td>
                                <td>$10$</td>
                                <td>$11$</td>                      
                                <td>$12$</td>
                                <td>$14$</td>
                                <td>$16$</td>
                            </tr>
                        </table>
                    </section>
                    <section>
                        <h4>Задача о выборе процессов</h4>
                        <p>
                            <img src="05/processes_task.png">
                        </p>
                    </section>
                    <section>
                        <h4>Задача о выборе процессов</h4>
                        <p align="left">
                            Покажем, что задача образует оптимальную подструктуру:
                        </p>
                        <ul>
                            <li>Пусть $S_{ij}$ – подмножество процессов, работающих между $i$-ым и $j$-ым процессом, $A_{ij}$ – оптимальное (максимального размера) подмножество таких процессов</li>
                            <li>Пусть $A_{ij}$ содержит некоторый процесс $a_k$</li>
                            <li>Тогда $A_{ij} = A_{ik} \cup \{a_k\} \cup A_{kj}$ (можно доказать от противного, см. [1])</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Оптимальная подструктура</h4>
                        <ul>
                            <li>То есть, выбрав процесс $a_k$, нам нужно рекурсивно искать оптимальные подмножества среди процессов, запускающихся после завершения $a_k$ и среди процессов, завершающихся до запуска $a_k$ (см. рисунок на след слайде)</li>
                            <li>Вопрос состоит в том, как выбрать $a_k$</li>
                            <li>Очевидно, $a_k$ нужно выбирать так, чтобы максимизировать количество процессов в $A_{ij}$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Шаг решения</h4>
                        <p>
                            <img src="05/processes_solving_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Описание рисунка</h4>
                        <p align="left">
                            На рисунке:
                        </p>
                        <ul>
                            <li>Красным выделен процесс $a_k$ ($k = 4$)</li>
                            <li>Серым выделены процессы, не входящие в подмножества $A_{ik}$ и $A_{kj}$, т.к. они пересекаются с $a_k$</li>
                            <li>Пунктирными линиями показаны границы процесса $a_k$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Рекурсивная формула</h4>
                        <ul>
                            <li>Запишем формулу для получения наибольшего количества процессов</li>
                            <li>Обозначим за $c[i, j]$ размер оптимального подмножества для процессов между $i$-ым и $j$-ым</li>
                            <li>Тогда:</li>
                            $$
                            \begin{equation*}
                                c[i, j] = 
                                \begin{cases}
                                    \underset{a_k \in S_{ij}}{max}\{c[i, k] + c[k, j] + 1\},&S_{ij} \neq \emptyset,\\
                                    0, &S_{ij} = \emptyset.
                                \end{cases}
                            \end{equation*}
                            $$
                        </ul>
                    </section>
                    <section>
                        <h4>Оптимальная подструктура</h4>
                        <ul>
                            <li>Как видно, оптимальное решение для большой задачи снова включает оптимальные решения для подзадач</li>
                            <li>Также можно показать, что в данном алгоритме присутствуют пересекающиеся подзадачи</li>
                            <li>Таким образом, эту задачу можно решать с помощью динамического программирования, запоминая решения для всех $c[i, j]$</li>
                        </ul>
                    </section>
                </section>
                <section>    
                    <section>
                        <h4>Жадный выбор</h4>
                        <ul>
                            <li>Обратим внимание на важный момент: в двух рассмотренных задачах в целях оптимизации мы делали из ряда оптимальных решений, получая их посредство рекурсивного решения меньших подзадач</li>
                            <li>Такой подход довольно успешен, но иногда можно сделать решение более эффективным посредством <b>жадного выбора</b></li>
                            <li><b>Жадный выбор</b> – такой выбор подзадачи, который представляется оптимальным до её непосредственного решения</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Жадный выбор</h4>
                        <ul>
                            <li>Можно применить жадный выбор в данной задаче</li>
                            <li>Тогда, вместо перебора всех $a_k$ в поисках оптимальной комбинации подзадач, будем всегда брать процесс, заканчивающийся раньше остальных</li>
                            <li>Если изначально мы отсортировали процессы по времени окончания, такой выбор оставит всего одну подзадачу вместо двух</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Жадный выбор</h4>
                        <ul>
                            <li>В [1] доказано, что такой жадный выбор приводит к оптимальному решению</li>
                            <li>Алгоритмы, осуществляющие жадный выбор вместо перебора всех вариантов, называются <b>жадными алгоритмами</b></li>
                            <li>Задачи, решаемые жадными алгоритмами, так же должны представлять оптимальную подструктуру, однако всегда необходимо доказывать, что жадный выбор действительно ведёт к оптимальному решению</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Демонстрация работы</h4>
                        <ul>
                            <li>Покажем, что жадный выбор работает для задачи о выборе процессов</li>
                            <li>На каждом шаге будем присоединять к решению процесс с наименьшим временем завершения</li>
                            <li>На рисунках красным выделен присоединяемый на данном шаге процесс, пунктиром – время окончания последнего процесса в оптимальном подмножестве</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Шаг 1</h4>
                        <p>
                            <img src="05/processes_solving_step_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 2</h4>
                        <p>
                            <img src="05/processes_solving_step_2.png">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 3</h4>
                        <p>
                            <img src="05/processes_solving_step_3.png">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 4</h4>
                        <p>
                            <img src="05/processes_solving_step_4.png">
                        </p>
                    </section>
                    <section>
                        <h4>Результат</h4>
                        <p>
                            <img src="05/processes_solving_step_5.png">
                        </p>
                    </section>
                    <section>
                        <h4>Демонстрация работы</h4>
                        <ul>
                            <li>На последнем рисунке показан результат работы жадного алгоритма: оптимальное подмножество из 4 процессов</li>
                            <li>Путём полного перебора можно увидеть, что это действителньо оптимальное решение (но есть ещё одно равносильное)</li>
                            <li>Данный жадный алгоритм работает за $O(N)$ в случае, если процессы отсортированы по времени завершения</li>
                            <li>Предыдущее решение этой задачи с мемоизацией работало за $O(N^2)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Континуальная задача о рюкзаке</h4>
                        <ul>
                            <li>Континуальная (непрерывная) задача о рюкзаке формируется так же, как дискретная, за тем лишь исключением, что вор может взять не весь предмет целиком, а любую его часть</li>
                            <li>Для дискретной задачи удобно представлять, что вор крадёт штучные товары, например, слитки драгоценных металлов</li>
                            <li>Для континуальной задачи более удобным представлением будет кража, к примеру, жидких химических соединений или песка драгоценных металлов</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Континуальная задача о рюкзаке</h4>
                        <ul>
                            <li>В отличие от дискретной задачи, жадный выбор в континуальной задаче о рюкзаке приводит к оптимальному решению</li>
                            <li>Выбор состоит в том, чтобы набирать максимальное количество товара с наибольшей стоимостью на единицу веса</li>
                            <li>Если такой товар закончился, а рюкзак не заполнен, можно переходить к второму по удельной стоимости товару и т.д.</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li>Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Главы 15, 16 – Основная книга нашего курса.</li>
                            <li>А.Левитин. Алгоритмы: введение в разработку и анализ. Главы 8 и 9. Более подробно рассмотрена задача о рюкзаке.</li>
                            <li>А. Скиена. Алгоритмы: руководство по разработке. Глава 8 – Наиболее краткое и простое изложение материала</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="4">                            
                            <li><a href='https://skillbox.ru/media/code/dinamicheskoe_programmirovanie_eto_prosto_reshaem_zadachu_o_ryukzake/'>Задача о рюкзаке</a> очень простыми словами</li>
                            <li><a href='https://academy.yandex.ru/handbook/algorithms/article/zadacha-o-ryukzake'>Ещё про задачу о рюкзаке</a> от академии Яндекса</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Материалы на английском</h4>
                        <ol>
                            <li><a href='https://algorithm-visualizer.org/dynamic-programming'>Визуализация</a> большого количества алгоритмов с кодом на JS</li>
                            <li><a href='https://avikdas.com/2019/04/15/a-graphical-introduction-to-dynamic-programming.html'>Введение</a> в динамическое программирование</li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>