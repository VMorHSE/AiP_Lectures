<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Алгоритмы поиска<div>&nbsp;</div>Оценка алгоритмов</h4>
                </section>
                <section>
                    <section>
                        <h4>Понятие алгоритма</h4>
                        <p align="left">
                            Алгоритм — набор инструкций, описывающих порядок действий исполнителя для решения определённой задачи
                        </p>
                    </section>
                    <section>
                        <h4>Свойства алгоритма</h4>
                        <ul>
                            <li>Дискретность</li>
                            <li>Детерминированность</li>
                            <li>Понятность</li>
                            <li>Конечность</li>
                            <li>Массовость</li>
                            <li>Результативность</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Данные</h4>
                        <ul>
                            <li>Алгоритм всегда принимает какие-то данные на вход и выдаёт какие-то данные в качестве результата</li>
                            <li>Таким образом, алгоритм можно представить как функцию, отображающую множество входных данных на множество выходных</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Оценка алгоритмов</h4>
                        <ul>
                            <li>Для одной задачи может существовать более одного алгоритма решения, и возникает вопрос, какой из них лучше</li>                   
                            <li>Чтобы оценить алгоритм, необходимо ввести специальную метрику</li>
                            <li>Наиболее распространённая метрика качества алгоритма — сложность</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Сложность алгоритма</h4>
                        <ul>
                            <li>Пусть некоторая функция $L_A$ возвращает сложность алгоритма $A$ для входных данных $x$</li>
                            <li>Зачастую значения такой функции сложно вычислимы</li>
                            <li>Поэтому сложность, как правило, выражается функцией не от самих входных данных, а от их объёма $N$</li>
                        </ul>
                        <p>
                            $L_A(N)$ — функция сложности алгоритма
                        </p>
                    </section>
                    <section>
                        <h4>Худшие случаи</h4>
                        <ul>
                            <li>Сложность работы алгорима может зависеть не только от объёма входных данных $N$, но и от самих данных $x$</li>
                            <li>Чтобы выражать сложность функцией от $N$, принято сложностью алгоритма считать его сложность на худшем наборе входных данных</li>
                            <p>
                                $L_A(N) = max(L_A(x_i)), x = 1..N$
                            </p>
                        </ul>
                    </section>
                    <section>
                        <h4>Единицы измерения сложности</h4>
                        <p align="left">
                            Функция $L_A(N)$ возвращает сложность алгоритма, выраженную в:
                        </p>
                        <ul>
                            <li>Количество арифметических операций</li>
                            <li>Количество операций сравнения</li>
                            <li>Количество обращений к памяти</li>
                            <li>Занимаемая память</li>
                            <li>Логические элементы</li>
                            <li>Время выполнения на эталонном вычислителе</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Задача поиска в упорядоченном массиве</h4>
                        <p align="left">
                            Дано:
                        </p>
                            <ul>
                                <li>Упорядоченный массив $a_1 &lt; a_2 &lt; \ldots &lt; a_N$</li>
                                <li>Число $x$ такое, что $\exists i: a_i = x$</li>
                            </ul>
                        <p align="left">
                            Найти: $i$, такое, что $a_i = x$
                        </p>
                    </section>
                    <section>
                        <h4>Алгоритм линейного поиска</h4>
                        <p align="left">
                            Тривиальным решением задачи является алгоритм линейного поиска:
                        </p>
                        <ol>
                            <li>Пусть $i = 1$</li>
                            <li>Пока $a_i &lt; x$ выполнять:</li>
                            <ol>
                                <li>
                                    Увелечить значение $i$ на $1$
                                </li>
                            </ol>
                            <li>Вернуть $i$</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Сложность линейного поиска</h4>
                        <ul>
                            <li>Выразим сложность алгоритма в количестве сравнений $x$ с $a_i$</li>
                            <li>Очевидно, худшим набором входных данных для этого алгоритма будет тот, где $x = a_N$, тогда:</li>
                        </ul>
                        <p>
                            $L_A(N) = N - 1$
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Дерево решений</h4>
                        <p align="left">
                            Алгоритм поиска для фиксированного количества элементов можно представить двоичным деревом решений, в котором:
                        </p>
                        <ul>
                            <li>Поиск начинается с корня</li>
                            <li>Каждый узел содержит номер элемента, с которым ведётся сравнение</li>
                            <li>Переход влево осуществляется, если $x \leqslant a_i$</li>
                            <li>Переход вправо осуществляется, если $x &gt; a_i$</li>
                            <li>Листья содержат результат поиска</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево линейного поиска для $N = 4$</h4>
                        <p>
                            <img src="01/lin_tree.png" width="700" height="550">
                        </p>
                    </section>
                    <section>
                        <h4>Дерево линейного поиска</h4>
                        <ul>
                            <li>Как видно, для линейного поиска дерево вырождается в одну ветвь с небольшими ответвлениями</li>
                            <li>Сложность поиска можно проследить по количеству "спусков" по ветвям</li>
                            <li>Можно усовершенствовать алгоритм поиска, сбалансировав дерево</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево двоичного поиска для $N = 6$</h4>
                        <p>
                            <img src="01/bin_tree.png" width="950" height="550">
                        </p>
                    </section>
                    <section>
                        <h4>Алгоритм двоичного поиска</h4>
                        <ol>
                            <li>Пусть $l_1 = 1$, $l_2 = N$</li>
                            <li>Пока $l_1 \neq l_2$, выполнять:</li>
                            <ol>
                                <li>Пусть $k = \lfloor \frac{l_1 + l_2}{2} \rfloor$</li>
                                <li>Если $x &gt; a_k$:</li>
                                <ol>
                                    <li>
                                        Пусть $l_1 = k + 1$
                                    </li>
                                </ol>
                                <li>Иначе:</li>
                                <ol>
                                    <li>
                                        Пусть $l_2 = k$
                                    </li>
                                </ol>
                            </ol>
                            <li>Вернуть $l_1$</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Анализ двоичного поиска</h4>
                        <p align="left">
                            Попробуем выразить сложность $L_A(N)$ для алгоритма двоичного поиска, для этого воспользуемся деревом:
                        </p>
                        <ul>
                            <li>Как видно на слайде с деревом, максимальное количество сравнений равно максимальной глубине дерева</li>
                            <li>Если в дереве от 5 до 8 элементов, его максимальная глубина — 3</li>
                            <li>Если в дереве от 9 до 16 элементов, его максимальная глубина — 4</li>
                            <li>Так можно продолжать для любой степени 2</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Сложность двоичного поиска</h4>
                        $L_A(N) = \lceil \log_{2}(N) \rceil$
                    </section>
                    <section>
                        <h4>Ускорение</h4>
                        <ul>
                            <li>А что, если сравнение элементов может вернуть три значения: &lt;, &gt;, =?</li>
                            <li>Тогда во всех решение может быть принято в любом узле дерева, а не только в его листьях</li>
                            <li>Листья составляют более половины узлов дерева, поэтому задействование всех узлов позволит уменьшить число узлов менее чем вдвое, а высоту не более чем на 1</li>
                            <li>Python и C++ используют только знак &lt;</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <h4>Полезные источники</h4>
                    <ol>
                        <li><b>RU</b> <a href='https://mk.cs.msu.ru/images/c/c4/KNIGA1.pdf'>В.Б. Алексеев. Введение в теорию сложности алгоритмов.</a> Введение и раздел 1.1 — Математическое обоснование рассказанного</li>
                        <li><b>RU</b> <a href='https://ru.wikibooks.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA#Python_3'>Реализации двоичного поиска на разных ЯП</a></li>
                        <li><b>RU</b> <a href='https://habr.com/ru/articles/195996/'>Подробнее про логарифмы в алгоритмах</a></li>
                        <li><b>EN</b> <a href='https://youtu.be/SByG6SZdPQw'>Визуализация линейного поиска</a></li>
                        <li><b>EN</b> <a href='https://youtu.be/E6IOrZUpvSE'>Визуализация двоичного поиска</a></li>
                    </ol>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
        <script src="../plugin/math/math.js"></script>
        <script>
          Reveal.initialize({ plugins: [ RevealMath.KaTeX ] });
        </script>
	</body>
</html>