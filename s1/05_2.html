<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Жадные алгоритмы</h4>
                </section>
                <section>
                    <section>
                        <h4>Задача о размене</h4>
                        <p align="left">
                            Сформулируем простую практическую задачу:
                        </p>
                        <ul>
                            <li>У кассира есть неограниченное количество монет достоинством $50$, $25$, $10$, $5$ и $1$</li>
                            <li>Кассиру необходимо выдать сдачу размером $48$</li>
                            <li>Как выбрать монеты таким образом, чтобы потратить наименьшее их количество?</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Интуитивное решение</h4>
                        <ul>
                            <li>Как правило, кассиры, даже не задумываясь об этом, используют следущий алгоритм</li>
                            <li>Набирать монеты наибольшего достоинства до тех пор, пока сумма не превышает нужную, потом перейти к монете достоинством ниже и т.д.</li>
                            <li>Такой подход к решению задачи называется <b>жадным</b></li>
                        </ul>
                    </section>
                    <section>
                        <h4>Жадный подход</h4>
                        <ul>
                            <li>Задача о размене представляет собой классическую задачу оптимизации</li>
                            <li>Жадным представленный подход назван потому, что на каждом шаге оптимизации не проводится перебор всех возможных решений с выбором наилучшего</li>
                            <li>Вместо этого на каждом шаге мы &laquo;жадно хватаем&raquo; решение, которое кажется лучшим в данный момент, не заглядывая в будущее</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Критерии жадного выбора</h4>
                        <p align="left">
                            Сформулируем критерии жадного выбора, котрые позволяют сделать его правильно:
                        </p>
                        <ul>
                            <li>Допустимость — выбор должен удовлетворять ограничениям задачи</li>
                            <li>Локальная оптимальность — выбор должен быть лучшим среди всех доступных на данном шаге</li>
                            <li>Окончательность — однажды сделанный выбор не может быть изменён в ходе последующей работы алгоритма</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Критерии жадного выбора</h4>
                        <p align="left">
                            Продемонстрируем, как эти критерии выполнены в представленном решении задачи о размене:
                        </p>
                        <ul>
                            <li>Допустимость — мы берём только те монеты, добавление которых не превышает нужную сумму</li>
                            <li>Локальная оптимальность — выбор наибольшей монеты на каждом шаге более всего приближает нас к итоговой сумме</li>
                            <li>Окончательность — мы не меняем выбор монет</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Недостатки жадного подхода</h4>
                        <ul>
                            <li>Несмотря на простоту и эффективность жадного подхода, зачастую он не подходит для решения всех экземпляров задач</li>
                            <li>К примеру, для номиналов $5$, $4$ и $1$ наш алгоритм не даст верного решения для суммы $8$</li>
                            <li>Таким образом, при построении алгоритма с использованием жадного подхода необходимо уделять внимание доказательству его применимости в данной задаче</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Задача о выборе процессов</h4>
                        <p align="left">
                            Сформулируем ещё одну задачу:
                        </p>
                        <ul>
                            <li>Пусть есть однопроцессорный компьютер</li>
                            <li>Также есть множество процессов $S = \{a_1, a_2, ..., a_N\}$, готовых для выполнения</li>
                            <li>$i$-ый процесс должен работать в течение интервала времени $[s_i, f_i)$</li>
                            <li>Задача: выбрать максимальное подмножество непересекающихся по времени процессов</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <p align="left">
                            Рассмотрим пример входных данных для задачи, состоящий из $11$ процессов, отсортированных по времени завершения
                        </p>
                        <table>
                            <tr>
                                <th>$i$</th>
                                <td>$1$</td>
                                <td>$2$</td>
                                <td>$3$</td>
                                <td>$4$</td>
                                <td>$5$</td>
                                <td>$6$</td>
                                <td>$7$</td>
                                <td>$8$</td>                      
                                <td>$9$</td>
                                <td>$10$</td>
                                <td>$11$</td>
                            </tr>
                            <tr>
                                <th>$s_i$</th>
                                <td>$1$</td>
                                <td>$3$</td>
                                <td>$0$</td>
                                <td>$5$</td>
                                <td>$3$</td>
                                <td>$5$</td>
                                <td>$6$</td>
                                <td>$8$</td>                      
                                <td>$8$</td>
                                <td>$2$</td>
                                <td>$12$</td>
                            </tr>
                            <tr>
                                <th>$f_i$</th>
                                <td>$4$</td>
                                <td>$5$</td>
                                <td>$6$</td>
                                <td>$7$</td>
                                <td>$9$</td>
                                <td>$9$</td>
                                <td>$10$</td>
                                <td>$11$</td>                      
                                <td>$12$</td>
                                <td>$14$</td>
                                <td>$16$</td>
                            </tr>
                        </table>
                    </section>
                    <section>
                        <h4>Задача о выборе процессов</h4>
                        <p>
                            <img src="05/processes_task.png">
                        </p>
                    </section>
                    <section>
                        <h4>Задача о выборе процессов</h4>
                        <p align="left">
                            Покажем, что задача образует оптимальную подструктуру:
                        </p>
                        <ul>
                            <li>Пусть $S_{ij}$ – подмножество процессов, работающих между $i$-ым и $j$-ым процессом, $A_{ij}$ – оптимальное (максимального размера) подмножество таких процессов</li>
                            <li>Пусть $A_{ij}$ содержит некоторый процесс $a_k$</li>
                            <li>Тогда $A_{ij} = A_{ik} \cup \{a_k\} \cup A_{kj}$ (можно доказать от противного, см. [1])</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Оптимальная подструктура</h4>
                        <ul>
                            <li>То есть, выбрав процесс $a_k$, нам нужно рекурсивно искать оптимальные подмножества среди процессов, запускающихся после завершения $a_k$ и среди процессов, завершающихся до запуска $a_k$ (см. рисунок на след слайде)</li>
                            <li>Вопрос состоит в том, как выбрать $a_k$</li>
                            <li>Очевидно, $a_k$ нужно выбирать так, чтобы максимизировать количество процессов в $A_{ij}$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Шаг решения</h4>
                        <p>
                            <img src="05/processes_solving_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Описание рисунка</h4>
                        <p align="left">
                            На рисунке:
                        </p>
                        <ul>
                            <li>Красным выделен процесс $a_k$ ($k = 4$)</li>
                            <li>Серым выделены процессы, не входящие в подмножества $A_{ik}$ и $A_{kj}$, т.к. они пересекаются с $a_k$</li>
                            <li>Пунктирными линиями показаны границы процесса $a_k$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Рекурсивная формула</h4>
                        <ul>
                            <li>Запишем формулу для получения наибольшего количества процессов</li>
                            <li>Обозначим за $c[i, j]$ размер оптимального подмножества для процессов между $i$-ым и $j$-ым</li>
                            <li>Тогда:</li>
                            $$
                            \begin{equation*}
                                c[i, j] = 
                                \begin{cases}
                                    \underset{a_k \in S_{ij}}{max}\{c[i, k] + c[k, j] + 1\},&S_{ij} \neq \emptyset,\\
                                    0, &S_{ij} = \emptyset.
                                \end{cases}
                            \end{equation*}
                            $$
                        </ul>
                    </section>
                    <section>
                        <h4>Оптимальная подструктура</h4>
                        <ul>
                            <li>Как видно, оптимальное решение для большой задачи снова включает оптимальные решения для подзадач</li>
                            <li>Также можно показать, что в данном алгоритме присутствуют пересекающиеся подзадачи</li>
                            <li>Таким образом, эту задачу можно решать с помощью динамического программирования, запоминая решения для всех $c[i, j]$</li>
                        </ul>
                    </section>
                </section>
                <section>    
                    <section>
                        <h4>Жадный выбор</h4>
                        <ul>
                            <li>Обратим внимание на важный момент: в рассмотренных ранее задачах оптимизации мы делали выбор из ряда оптимальных решений, получая их посредством рекурсивного решения меньших подзадач</li>
                            <li>Такой подход довольно успешен, но иногда можно сделать решение более эффективным посредством <b>жадного выбора</b></li>
                            <li><b>Жадный выбор</b> – такой выбор подзадачи, который представляется оптимальным до её непосредственного решения</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Жадный выбор</h4>
                        <ul>
                            <li>Можно применить жадный выбор в данной задаче</li>
                            <li>Тогда, вместо перебора всех $a_k$ в поисках оптимальной комбинации подзадач, будем всегда брать процесс, заканчивающийся раньше остальных</li>
                            <li>Если изначально мы отсортировали процессы по времени окончания, такой выбор оставит всего одну подзадачу вместо двух</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Жадный выбор</h4>
                        <ul>
                            <li>В [1] доказано, что такой жадный выбор приводит к оптимальному решению</li>
                            <li>Алгоритмы, осуществляющие жадный выбор вместо перебора всех вариантов, называются <b>жадными алгоритмами</b></li>
                            <li>Задачи, решаемые жадными алгоритмами, так же должны представлять оптимальную подструктуру, однако всегда необходимо доказывать, что жадный выбор действительно ведёт к оптимальному решению</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Демонстрация работы</h4>
                        <ul>
                            <li>Покажем, что жадный выбор работает для задачи о выборе процессов</li>
                            <li>На каждом шаге будем присоединять к решению процесс с наименьшим временем завершения</li>
                            <li>На рисунках красным выделен присоединяемый на данном шаге процесс, пунктиром – время окончания последнего процесса в оптимальном подмножестве</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Шаг 1</h4>
                        <p>
                            <img src="05/processes_solving_step_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 2</h4>
                        <p>
                            <img src="05/processes_solving_step_2.png">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 3</h4>
                        <p>
                            <img src="05/processes_solving_step_3.png">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 4</h4>
                        <p>
                            <img src="05/processes_solving_step_4.png">
                        </p>
                    </section>
                    <section>
                        <h4>Результат</h4>
                        <p>
                            <img src="05/processes_solving_step_5.png">
                        </p>
                    </section>
                    <section>
                        <h4>Демонстрация работы</h4>
                        <ul>
                            <li>На последнем рисунке показан результат работы жадного алгоритма: оптимальное подмножество из $4$ процессов</li>
                            <li>Путём полного перебора можно увидеть, что это действителньо оптимальное решение (но есть ещё одно равносильное)</li>
                            <li>Данный жадный алгоритм работает за $O(N)$ в случае, если процессы отсортированы по времени завершения</li>
                            <li>Предыдущее решение этой задачи с мемоизацией работало за $O(N^2)$</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Континуальная задача о рюкзаке</h4>
                        <ul>
                            <li>Континуальная (непрерывная) задача о рюкзаке формируется так же, как дискретная, за тем лишь исключением, что вор может взять не весь предмет целиком, а любую его часть</li>
                            <li>Для дискретной задачи удобно представлять, что вор крадёт штучные товары, например, слитки драгоценных металлов</li>
                            <li>Для континуальной задачи более удобным представлением будет кража, к примеру, жидких химических соединений или песка драгоценных металлов</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Континуальная задача о рюкзаке</h4>
                        <ul>
                            <li>В отличие от дискретной задачи, жадный выбор в континуальной задаче о рюкзаке приводит к оптимальному решению</li>
                            <li>Выбор состоит в том, чтобы набирать максимальное количество товара с наибольшей стоимостью на единицу веса</li>
                            <li>Если такой товар закончился, а рюкзак не заполнен, можно переходить к второму по удельной стоимости товару и т.д.</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример задачи</h4>
                        <p align="left">
                            В качестве примера возьмём маленький экземпляр задачи о рюкзаке со следующими параметрами: $W = 4$
                        </p>
                        <table>
                            <tr>
                                <th>$i$</th>
                                <td>$1$</td>
                                <td>$2$</td>
                                <td>$3$</td>
                                <td>$4$</td>
                            </tr>
                            <tr>
                                <th>$v_i$</th>
                                <td>$12$</td>
                                <td>$10$</td>
                                <td>$20$</td>
                                <td>$15$</td>
                            </tr>
                            <tr>
                                <th>$w_i$</th>
                                <td>$2$</td>
                                <td>$1$</td>
                                <td>$3$</td>
                                <td>$2$</td>
                            </tr>
                        </table>
                    </section>
                    <section>
                        <h4>Решение</h4>
                        <p align="left">
                            Для начала вычислим удельные стоимости предметов (на единицу веса)
                        </p>
                        <table>
                            <tr>
                                <th>$i$</th>
                                <td>$1$</td>
                                <td>$2$</td>
                                <td>$3$</td>
                                <td>$4$</td>
                            </tr>
                            <tr>
                                <th>$v_i$</th>
                                <td>$12$</td>
                                <td>$10$</td>
                                <td>$20$</td>
                                <td>$15$</td>
                            </tr>
                            <tr>
                                <th>$w_i$</th>
                                <td>$2$</td>
                                <td>$1$</td>
                                <td>$3$</td>
                                <td>$2$</td>
                            </tr>
                            <tr>
                                <th>$v_i / w_i$</th>
                                <td>$6$</td>
                                <td>$10$</td>
                                <td>$6.67$</td>
                                <td>$7.5$</td>
                            </tr>
                        </table>
                    </section>
                    <section>
                        <h4>Решение</h4>
                        <p align="left">
                            Теперь будем брать максимум предметов с наибольшей удельной стоимостью
                        </p>
                        <ul>
                            <li>Начнём с предмета $2$, он поместится в рюкзак целиком и останется $3$ места</li>
                            <li>Далее положим весь предмет $4$, после чего останется $1$ места</li>
                            <li>И, наконец, положим $1$ единицу предмета $3$, после чего место закончится, а суммарная стоимость составит $1 \cdot 10 + 2 \cdot 7.5 + 1 \cdot 6.67 = 31.67$</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Кодирование информации</h4>
                        <ul>
                            <li>Пусть дан текст из $N$ символов, составленный только из букв некоторого алфавита $A$</li>
                            <li>Пусть также для каждого символа известна частота его появления в тексте $f$</li>
                            <li>Необходимо закодировать каждый символ текста двоичными числами для передачи по каналу связи</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример задачи</h4>
                        <ul>
                            <li>Пусть $N = 100000$, $A = \{a, b, c, d\}$</li>
                            <li>Частоты появления символов представлены в таблице</li>
                        </ul>
                        <table>
                            <tr>
                                <th>Символ</th> <td>$a$</td> <td>$b$</td> <td>$c$</td> <td>$d$</td>
                            </tr>
                            <tr>
                                <th>Частота</th> <td>$0.75$</td> <td>$0.2$</td> <td>$0.04$</td> <td>$0.01$</td>
                            </tr>
                        </table>
                    </section>
                    <section>
                        <h4>Пример решения</h4>
                        <ul>
                            <li>Воспользуемся простым решением — построим <b>равномерный код</b></li>
                            <li>Это такой код, где каждому символу сопоставляется одинаковое количество бит</li>
                            <table>
                                <tr>
                                    <th>Символ</th> <td>$a$</td> <td>$b$</td> <td>$c$</td> <td>$d$</td>
                                </tr>
                                <tr>
                                    <th>Код</th> <td>$00$</td> <td>$01$</td> <td>$10$</td> <td>$11$</td>
                                </tr>
                            </table>
                            <li>Таким образом, для кодирования $100000$ символов понадобится $200000$ бит</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Альтернативное решение</h4>
                        <ul>
                            <li>А теперь возмём <b>код переменной длины</b></li>
                            <li>Например, такой:</li>
                            <table>
                                <tr>
                                    <th>Символ</th> <td>$a$</td> <td>$b$</td> <td>$c$</td> <td>$d$</td>
                                </tr>
                                <tr>
                                    <th>Код</th> <td>$0$</td> <td>$10$</td> <td>$110$</td> <td>$111$</td>
                                </tr>
                            </table>
                            <li>Для кодирования $100000$ символов в данном случае понадобится $100000 \cdot 0.75 \cdot 1 + 100000 \cdot 0.2 \cdot 2 + 100000 \cdot 0.04 \cdot 3 + 100000 \cdot 0.01 \cdot 3 = 130000$ бит</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Обсуждение решений</h4>
                        <ul>
                            <li>Как видно, код переменной длины дал выигрыш в $70000$ бит, что составляет $35\%$ от длины равномерного кода</li>
                            <li>Как построить такой код для произвольной задачи?</li>
                            <li>Прежде всего, необходимо отметить, что такой код должен быть <b>префиксным</b> — ни один код символа не должен быть началом кода другого символа</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево кодирования</h4>
                        <ul>
                            <li>Чтобы строить префиксные коды, удобно пользоваться <b>деревьями кодирования</b></li>
                            <li>Это двоичные деревья, листья которых представляют кодируемые символы</li>
                            <li>В нелистовых узлах помещается сумма частот дочерних узлов</li>
                            <li>Ребро к правому потомку помечается битом $1$, к левому — битом $0$</li>
                            <li>Построим такое дерево для нашего равномерного кода</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево кодирования для равномерного кода</h4>
                        <p>
                            <img src="05/coding_tree_fixed.png">
                        </p>
                    </section>
                    <section>
                        <h4>Пояснения</h4>
                        <ul>
                            <li>Код символа в представленном дереве можно получить, пройдя по простому пути от корня до нужного листа и выписав метки рёбер</li>
                            <li>Эффективность дерева определяется его <b>весом</b> — суммой произведений частот символов на их глубину в дереве</li>
                            <li>Вес представленного дерева: $2 \cdot 0.75 + 2 \cdot 0.2 + 2 \cdot 0.04 + 2 \cdot 0.01 = 2$</li>
                            <li>Построим такое дерево для кода переменной длины</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево кодирования для кода переменной длины</h4>
                        <p>
                            <img src="05/coding_tree_var.png" width="70%" height="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Обсуждение</h4>
                        <ul>
                            <li>Вес представленного дерева $1 \cdot 0.75 + 2 \cdot 0.2 + 3 \cdot 0.04 + 3 \cdot 0.01 = 1.3$</li>
                            <li>Остаётся вопрос: как строить такие деревья?</li>
                            <li>В 1952 году Дэвид Хаффман разработал жадный алгоритм, который позволяет это делать</li>
                            <li>Получаемые с помощью этого алгоритма оптимальные префиксные коды называются <b>кодами Хаффмана</b></li>
                        </ul>
                    </section>
                    <section>
                        <h4>Построение кода Хаффмана</h4>
                        <ol>
                            <li>Поместить все листья-символы в очередь с приоритетами</li>
                            <li>Извлечь из очереди два узла с наименьшими частотами и соединить их в один узел дерева</li>
                            <li>Поместить полученный узел в очередь</li>
                            <li>Пока в очереди есть узлы, возвращаться к шагу $2$</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Шаг 1</h4>
                        <p>
                            <img src="05/huffman_step_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 2</h4>
                        <p>
                            <img src="05/huffman_step_2.png" width="70%" height="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 3</h4>
                        <p>
                            <img src="05/huffman_step_3.png" width="70%" height="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 4</h4>
                        <p>
                            <img src="05/huffman_step_4.png" width="70%" height="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 5</h4>
                        <p>
                            <img src="05/huffman_step_5.png" width="70%" height="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Шаг 6</h4>
                        <p>
                            <img src="05/huffman_step_6.png" width="70%" height="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Результат</h4>
                        <p>
                            <img src="05/huffman_result.png" width="70%" height="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Обсуждение</h4>
                        <ul>
                            <li>Алгоритм построения кодов Хаффмана считается жадным, потому что на каждом шаге наиболее глубокую позицию в дереве занимает пара узлов с наименьшей суммарной частотой</li>
                            <li>Доказательство корректности данного алгоритма представлено в [1]</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li>Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 16 — Основная книга нашего курса.</li>
                            <li>А.Левитин. Алгоритмы: введение в разработку и анализ. Глава 9. Описана задача о размене и деревья Хаффмана.</li>
                            <li><a href='https://habr.com/ru/companies/otus/articles/497566/'>Альтернативное изложение</a> материала про коды Хаффмана с кодом на C++</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="4">                         
                            <li><a href='https://en.wikipedia.org/wiki/Continuous_knapsack_problem'>Немного подробнее</a> про континуальную задачу о рюкзаке</li>                            
                            <li><a href='https://cmps-people.ok.ubc.ca/ylucet/DS/Huffman.html'>Визуализация</a> построения кодов Хаффмана</li>                            
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>