<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">
        <link rel="stylesheet" href="">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
        <style>
            .reveal .slides section .fragment.step-fade-in-then-out {
                opacity: 0;
                display: none; }
            .reveal .slides section .fragment.step-fade-in-then-out.current-fragment {
                opacity: 1;
                display: inline; }
            .reveal .slides section .fragment.step-fade-in {
                opacity: 0;
                display: none; }
            .reveal .slides section .fragment.step-fade-in.current-fragment {
                opacity: 1;
                display: inline; }
            .reveal .slides section .fragment.step-fade-out {
                opacity: 0;
                display: none; }
            .reveal .slides section .fragment.step-fade-out.current-fragment {
                opacity: 1;
                display: inline; }
        </style>
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Поиск подстроки (часть $2$)</h4>
                </section>
                <section>
                    <h4>Продолжение</h4>
                    <ul>
                        <li>На предыдущей лекции был рассмотрен эффективный алгоритм поиска подстроки в строке</li>
                        <li>Однако практические испытания показывают, что он хорошо подходит только для обработки текстов с коротким алфавитом (таких, как ДНК-последовательности)</li>
                        <li>Сегодня мы рассмотрим алгоритм, который наиболее эффективен для текстов на естественных языках</li>
                    </ul>
                </section>
                <section>
                    <section>
                        <h4>Новые правила сдвигов</h4>
                        <ul>
                            <li>
                                Бойер и Мур в 1977 году разработали алгоритм, основанный на трёх правилах сдвигов:
                                <ol>
                                    <li>Правило обратного просмотра</li>
                                    <li>Правило плохого символа</li>
                                    <li>Правило хорошего суффикса</li>
                                </ol>
                            </li>
                            <li>Они чем-то похожи на те, которые мы ввели интуитивно, но есть и отличия</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Правило обратного просмотра</h4>
                        <ul>
                            <li>В алгоритме Кнута-Морриса-Пратта мы "прикладывали" подстроку к строке и начинали поочерёдно сравнивать символы <b>слева направо</b></li>
                            <li>Правило обратного просмотра гласит, что символы следует просматривать <b>справа налево</b>, начиная от последнего символа подстроки</li>
                            <li>Такой подход обоснован тем, что во многих естественных языках начала слов чаще совпадают, а концы чаще различаются</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Пример</h4>
                        <ul>
                            <li>Пусть, напирмер, дана строка $t$ длины $12$ и подстрока $s$ длины $7$</li>
                            <li>В процессе работы некоторого алгоритма уже был произведён сдвиг подстроки на $2$ позиции вправо и просмотр начинается с правого символа подстроки</li>
                            <li>Дойдя до третьего символа подстроки, мы останавливем просмотр, т.к. встретили несоответствие (т.е. $t[6..9] = s[4..7]$)</li>
                            <li>На сколько позиций можно сдвинуть подстроку?</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <table>
                            <tbody>
                                <tr>
                                    <th scope="row">$i=$</th>
                                    <td>$1$</td> <td>$2$</td> <td>$3$</td> <td>$4$</td> <td>$5$</td> <td>$6$</td> <td>$7$</td> <td>$8$</td> <td>$9$</td> <td>$10$</td> <td>$11$</td> <td>$12$</td>
                                </tr>
                                <tr>
                                    <th scope="row">$t=$</th>
                                    <td>$x$</td> <td>$p$</td> <td>$b$</td> <td>$c$</td> <td>$t$</td> <td>$t_6$</td> <td>$t_7$</td> <td>$t_8$</td> <td>$t_9$</td> <td>$t_{10}$</td> <td>$t_{11}$</td> <td>$t_{12}$</td>
                                </tr>
                                <tr>
                                    <th scope="row">$s=$</th>
                                    <td>$ $</td> <td>$ $</td> <td>$t$</td> <td>$p$</td> <td>$a$</td> <td>$s_4$</td> <td>$s_5$</td> <td>$s_6$</td> <td>$s_7$</td> <td>$ $</td> <td>$ $</td> <td>$ $</td>
                                </tr>
                                <tr>
                                    <th scope="row">$pos$</th>
                                    <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$\uparrow$</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>На сколько позиций можно сдвинуть подстроку?</p>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <p>На $2$ позиции</p>
                        <table>
                            <tbody>
                                <tr>
                                    <th scope="row">$i=$</th>
                                    <td>$1$</td> <td>$2$</td> <td>$3$</td> <td>$4$</td> <td>$5$</td> <td>$6$</td> <td>$7$</td> <td>$8$</td> <td>$9$</td> <td>$10$</td> <td>$11$</td> <td>$12$</td>
                                </tr>
                                <tr>
                                    <th scope="row">$t=$</th>
                                    <td>$x$</td> <td>$p$</td> <td>$b$</td> <td>$c$</td> <td>$t$</td> <td>$t_6$</td> <td>$t_7$</td> <td>$t_8$</td> <td>$t_9$</td> <td>$t_{10}$</td> <td>$t_{11}$</td> <td>$t_{12}$</td>
                                </tr>
                                <tr>
                                    <th scope="row">$s=$</th>
                                    <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$t$</td> <td>$p$</td> <td>$a$</td> <td>$s_4$</td> <td>$s_5$</td> <td>$s_6$</td> <td>$s_7$</td> <td>$ $</td>
                                </tr>
                                <tr>
                                    <th scope="row">$pos$</th>
                                    <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$ $</td> <td>$\uparrow$</td> <td>$ $</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section>
                        <h4>Правило плохого символа</h4>
                        <ul>
                            <li>В общем случае, встретив несоответствие <nobr>$j$-ого</nobr> символа подстроки с $i$-ым символом строки, мы можем двигать подстроку вправо до тех пор, пока под $i$-ым символом строки не окажется совпадающий с ним символ подстроки</li>
                            <li>Если таких символов в подстроке нет, можно двигать так, чтобы вся подстрока оказалась правее $i$-ого символа строки</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Правило плохого символа</h4>
                        <ul>
                            <li>Выразим правило более формально</li>
                            <li>Пусть есть некоторая функция $R: \Sigma \rightarrow \N$, принимающая символ подстроки и возвращающая позицию самого правого вхождения символа в эту подстроку ($\Sigma$ – алфавит – множество различных символов, которые содержит подстрока)</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Правило плохого символа</h4>
                        <ul>
                            <li>Тогда правило плохого символа гласит, что при несоответствии $i$-ого символа строки $t$ в процессе сравнения $j$-ому символу подстроки $s$ подстрока $s$ может быть сдвинута на $max(1, j - R(t_i))$ позиций вправо</li>
                            <li>Т.е., если самый правый символ, равный $t_i$, встретился в подстроке правее, чем $j$, она сдвигается только на $1$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Правило плохого символа</h4>
                        <ul>
                            <li>Как видно, в некоторых случаях это правило не позволяет делать эффективные сдвиги, т.к. функция $R$ слишком проста и хранит только возицию самого правого вхождения</li>
                            <li>Однако в оригинальном алгоритме использовалось именно оно из-за простоты реализации</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Расширенное правило плохого символа</h4>
                        <ul>
                            <li>Правило плохого символа можно расширить, добавив условие, чтобы $R$ возвращала самую правую позицию вхождения символа $t_i$ в $s$ <b>левее позиции $j$</b></li>
                            <li>Тогда, чтобы реализовать $R$, нужно для подстроки $s$ хранить таблицу позиций вхождений каждого символа, причём упорядочить эти вхождения по убыванию</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Код построения таблицы</h4>
                        <p align="left">Далее представлен под построения таблицы $R$ для подстроки $s$</p>
                        <pre><code data-trim class="python">
                            def build_r(s):
                                R = dict()
                                for i in range(len(s) - 1, -1, -1):
                                    if s[i] not in R:
                                        R[s[i]] = [i]
                                    else:
                                        R[s[i]].append(i)
                                return R
                        </code></pre>
                        <p align="left">Например, для подстроки <code data-trim class="python">'abacbabc'</code> будет построена таблица <nobr><code data-trim class="python">{'c': [7, 3], 'b': [6, 4, 1], 'a': [5, 2, 0]}</code></nobr></p>
                    </section>
                    <section>
                        <h4>Сложность применения правила</h4>
                        <ul>
                            <li>При применении расширенного правила для несовпадения в позиции $j$ подстроки $s$ нужно будет сделать максимум $M - j$ сравнений</li>
                            <li>Это количество равно количеству совпавших символов, что в результате для всех итераций может, в худшем случае, удвоить время работы всего алгоритма</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Правило хорошего суффикса</h4>
                        <ul>
                            <li>Правило хорошего суффикса сложнее предыдущих двух, сформулируем его поэтапно</li>
                            <li>Пусть на очередной итерации алгоритма поиска подстроки во время сравнения справа налево было обнаружено совпадение некоторого суффикса $w$ подстроки $s$ с частью строки $t$</li>
                            <li>Однако для символа, предшествующего этому суффиксу, было обнаружено несовпадение</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Графическое представление</h4>
                        <p>
                            <img src="08/good_suff_step_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Правило хорошего суффикса</h4>
                        <ul>
                            <li>Найдём фрагмент $w' = w$ подстроки $s$, не являющийся её суффиксом (т.е. не совпадающий с $w$)</li>
                            <li>При поиске будем учитывать, чтобы символ, предшествующий $w'$, если он существует, не совпадал с символом, предшествующим $w$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Графическое представление</h4>
                        <p>
                            <img src="08/good_suff_step_2.png">
                        </p>
                    </section>
                    <section>
                        <h4>Правило хорошего суффикса</h4>
                        <ul>
                            <li>Если такой фрагмент $w'$ найден, сдвигаем $s$ так, чтобы $w'$ оказался под той частью строки $t$, под котрой был $w$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Графическое представление</h4>
                        <p>
                            <img src="08/good_suff_step_3.png">
                        </p>
                    </section>
                    <section>
                        <h4>Правило хорошего суффикса</h4>
                        <ul>
                            <li>Теперь представим ситуацию, когда такой фрагмент $w'$ не найден в подстроке $s$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Графическое представление</h4>
                        <p>
                            <img src="08/good_suff_step_2_alt_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Правило хорошего суффикса</h4>
                        <ul>
                            <li>В таком случае необходимо сдвинуть подстроку так, чтобы какой-то её префикс совпал с каким-то суффиксом фрагмента $w$ из строки $t$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Графическое представление</h4>
                        <p>
                            <img src="08/good_suff_step_3_alt_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Правило хорошего суффикса</h4>
                        <ul>
                            <li>Сдвиг, аналогичный последнему рассмотренному, выполняется также в случае, когда было найдено вхождение подстроки $s$ в строку $t$ (т.е. все символы совпали)</li>
                            <li>Если же префиксов $s$, совпадающих с суффиксами фрагмента $w$ из строки $t$, не нашлось, подстрока сдвигается так, чтобы она полностью оказалась правее фрагмента $w$ из строки $t$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Формализация правила</h4>
                        <ul>
                            <li>Введём некоторые обозначения</li>
                            <li>Пусть для каждого $j$-ого символа в подстроке $s$ определено значение ${L'}_j &lt; M$</li>
                            <li>${L'}_j$ – наибольшая позиция в $s$ такая, что $s[j..M]$ является суффиксом $s[1..{L'}_j]$ и при этом символ, предшествующий этому суффиксу, не равен $s_{j - 1}$</li>
                            <li>Если такой позиции нет, ${L'}_j = 0$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Примеры</h4>
                        <ul>
                            <li>Вычислим значения $L'$ для нескольких строк</li>
                            <li>$abababab$ $\rightarrow$ <span class="fragment">$0, 0, 6, 0, 4, 0, 2, 0$</span></li>
                            <li>$dbabbab$ $\rightarrow$ <span class="fragment">$0, 0, 0, 0, 4, 0, 5$</span></li>
                            <li>$cabdabdab$ $\rightarrow$ <span class="fragment">$0, 0, 0, 0, 6, 0, 0, 3, 0$</span></li>
                        </ul>
                    </section>
                    <section>
                        <h4>Суть формализации</h4>
                        <ul>
                            <li>Как можно видеть из примеров, ${L'}_j$ показывает правый конец самой правого фрагмента $s$, совпадающего с суффиксом $s$ размера <nobr>$M - j + 1$</nobr></li>
                            <li>При этом фрагмент должен быть таким, чтобы предшествующий ему символ не совпадал с символом, предшествующим суффиксу</li>
                            <li>Тогда при несовпадении символа в позиции $j - 1$ мы можем двигать подстроку $s$ на $M - {L'}_j$ позиций вправо</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Недостатки</h4>
                        <ul>
                            <li>Однако, остались необработанными ещё три ситуации</li>
                            <li>Во-первых, несовпадение может встретиться сразу же, т.е. при $j = M$, тогда мы двигаем подстроку на $1$</li>
                            <li>Во-вторых, ${L'}_j$ может быть равно $0$</li>
                            <li>В-третьих, мы можем найти вхождение $s$ в $t$ и тогда индекс несовпадения не определён</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Решение</h4>
                        <ul>
                            <li>Как следует из определения правила, в двух последних случаях необходимо двигать подстроку так, чтобы какой-то её префикс совпал с каким-то суффиксом рассмотренной части строки $t$</li>
                            <li>Чтобы реализовать это, введём $l'$</li>
                            <li>${l'}_i$ – длина наибольшего суффикса фрагмента $s[i..M]$ такого, что он также является префиксом $s$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Применение решения</h4>
                        <ul>
                            <li>Тогда, если ${L'}_j = 0$, двигаем подстроку на $M - {l'}_j$ позиций</li>
                            <li>Если же найдено вхождение $s$ в $t$, двигаем на $M - {l'}_2$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Реализация правила</h4>
                        <ul>
                            <li>Чтобы показать, как эффективно рассчитать значения $L'$, введём ещё одно обозначение</li>
                            <li>Пусть для каждого $j$-ого символа в подстроке $s$ определено значение $N_j$</li>
                            <li>$N_j$ – длиннейший суффикс фрагмента $s[1..j]$, который одновременно является собственным суффиксом всей строки $s$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Примеры</h4>
                        <ul>
                            <li>Вычислим значения $N$ для тех же строк</li>
                            <li>$abababab$ $\rightarrow$ <span class="fragment">$0, 2, 0, 4, 0, 6, 0, 0$</span></li>
                            <li>$dbabbab$ $\rightarrow$ <span class="fragment">$0, 1, 0, 3, 1, 0, 0$</span></li>
                            <li>$cabdabdab$ $\rightarrow$ <span class="fragment">$0, 0, 2, 0, 0, 5, 0, 0, 0$</span></li>
                        </ul>
                    </section>
                    <section>
                        <h4>Переход</h4>
                        <ul>
                            <li>${L'}_i$ – наибольший индекс $j &lt; M$ такой, что $N_j = M - i + 1$</li>
                            <li>Тогда можно за $O(M)$ перейти от $N_j$ к ${L'}_j$</li>
                        </ul>
                        <pre><code data-trim class="python">
                            def N2L_prime(N):
                                M = len(N)
                                L_prime = [0] * M
                                for j in range(M - 1):
                                    if N[j] != 0:
                                        i = M - N[j]
                                        L_prime[i] = j
                                return L_prime
                        </code></pre>
                    </section>
                    <section>
                        <h4>Реализация правила</h4>
                        <ul>
                            <li>Однако до сих пор неясно, как эффективно найти значения $N_j$ и ${l'}_j$</li>
                            <li>В этом нам поможет алгоритм <b>фундаментальной предварительной обработки строк</b></li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Предварительная обработка</h4>
                        <ul>
                            <li>Оригинальный алгоритм предварительной обработки подстроки $s$ для выражения правила хорошего суффикса, представленный Бойером и Муром, достаточно сложен для понимания</li>
                            <li>Дэн Гасфилд в своей книге [1] ввёл алгоритм <b>фундаментальной предварительной обработки строк</b> или <b>$Z$-функцию</b>, которая позволяет проводить такую же обработку гораздо проще</li>
                        </ul>
                    </section>
                    <section>
                        <h4>$Z$-функция</h4>
                        <ul>
                            <li>Пусть есть строка $s$ длины $M$ и позиция $j &gt; 1$ в ней</li>
                            <li>Тогда значением $Z_i(s)$ будет длина наибольшего префикса фрагмента $s[i..M]$, совпадающего с префиксом всей строки $s$</li>
                            <li>Алгоритм называется фундаментальным, потому что от значений $Z$ можно за $O(M)$ перейти к значениям $N$, $l$ или даже значениям $\pi$ (с предыдущей лекции)</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Примеры</h4>
                        <ul>
                            <li>Вычислим значения $Z$ для нескольких строк</li>
                            <li>$abababab$ $\rightarrow$ <span class="fragment">$0, 0, 6, 0, 4, 0, 2, 0$</span></li>
                            <li>$dbabbab$ $\rightarrow$ <span class="fragment">$0, 0, 0, 0, 0, 0, 0$</span></li>
                            <li>$aabcaabxaaz$ $\rightarrow$ <span class="fragment">$0, 1, 0, 0, 3, 1, 0, 0, 2, 1, 0$</span></li>
                        </ul>
                    </section>
                    <section>
                        <h4>Вычисление</h4>
                        <ul>
                            <li>Чтобы эффективно вычислять значения <nobr>$Z$-функции</nobr>, необходимо ввести новые понятия</li>
                            <li>Обозначим как <b>отрезок совпадения</b> фрагмент подстроки $s$, начинающийся в $j$-той позиции и продлевающийся вправо на $Z_j(s)$ позиций, включая $j$-ую</li>
                            <li>Т.е. <b>отрезок совпадения</b> – тот самый префикс, начинающийся в позиции $j$ и совпадающий с префиксом всей подстроки</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Графическое представление</h4>
                        <p>
                            <img src="08/Z_boxes_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Вычисление</h4>
                        <ul>
                            <li>Для каждой позиции $j &gt; 1$ в подстроке $s$ также определим позици $r_j$ и $l_j$</li>
                            <li>$r_j$ – позиция наиболее правого конца отрезка совпадения, начинающегося в позиции $j$ или левее неё</li>
                            <li>$l_j$ – позиция левого конца такого отрезка совпадения</li>
                            <li>Если в позиции $r_j$ заканчивается более $1$ отрезка совпадения, в качестве $l_j$ можно взять левый конец любого из них</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Графическое представление</h4>
                        <p>
                            <img src="08/Z_boxes_2.png">
                        </p>
                    </section>
                    <section>
                        <h4>Вычисление</h4>
                        <ul>
                            <li>На $j$-ом шаге алгоритма нам понадобятся только значения $l_{j - 1}$ и $r_{j - 1}$ и никаких других значений $l$ и $r$</li>
                            <li>Тогда обозначим $l_{j - 1}$ и $r_{j - 1}$ просто как $l$ и $r$</li>
                            <li>Суть алгоритма – максимально использовать уже вычисленные значения</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Алгоритм</h4>
                        <ul>
                            <li>Отметим, что текущее значение $r$ показывает крайнюю правую позицию, которая была просмотрена алгоритмом; что стоит за ней, мы не знаем</li>
                            <li>
                                При обработке $j$-ого символа подстроки может возникнуть одна из двух ситуаций:
                                <ol>
                                    <li>$j &gt; r$, т.е. текущая позиция за пределами того, что уже обработано</li>
                                    <li>$j \leqslant r$, т.е. текущая позиция лежит в отрезке совпадения $[l..r]$</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Алгоритм</h4>
                        <ul>
                            <li>В первой ситуации не остаётся ничего, кроме применения тривиального алгоритма</li>
                            <li>Т.е. нам необходимо последовательно перебирать $Z_j = \overline{0..M - j}$ и сравнивать $s_{Z_j + 1}$ с $s_{Z_j + j}$, пока не будет встречено несовпадение</li>
                            <li>При несовпадении $Z_j$ будет как раз содержать длину совпавшей части</li>
                            <li>Если $Z_j &gt; 0$, нужно установить <nobr>$r = j + Z_j - 1$</nobr> и $l = j$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Алгоритм</h4>
                        <ul>
                            <li>Во второй ситуации можно использовать уже вычисленные значения $Z$, чтобы сразу инициализировать $Z_j$ значением, большим, чем $0$</li>
                            <li>Заметим, что фрагменты $s[r..l]$ и <nobr>$s[1..r-l+1]$</nobr> совпадают</li>
                            <li>Тогда $Z_j$ можно инициализировать соответствующим ему значением из фрагмента $s[1..r-l+1]$, а именно $Z_{j - l + 1}$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Алгоритм</h4>
                        <ul>
                            <li>Однако это можно делать только в случае, если $j + Z_{j - l + 1} - 1 &lt; r$, т.к. иначе значение выйдет за границы просмотренной части строки, где символы могут отличаться от нужных</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Графическое представление</h4>
                        <p>
                            <img src="08/Wrong_Z_box.png" width="80%" height="80%">
                        </p>
                    </section>
                    <section>
                        <h4>Алгоритм</h4>
                        <ul>
                            <li>Таким образом, для инициализации $Z_j$ можно безопасно взять только значение <nobr>$min(r - j + 1, Z_{j-l+1})$</nobr></li>
                            <li>Проинициализировав $Z_j$ таким образом, далее следует снова применять тривиальный алгоритм для сравнения значений после $r$ с соответствующим префиксом</li>
                            <li>Следовательно, отличие двух ситуаций состоит только в инициализации $Z_j$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Код</h4>
                        <pre><code data-trim class="python">
                            def z_func(s):
                                z = [0] * len(s)
                                left, right = 0, 0
                                for i in range(1, len(s)):
                                    z[i] = max(0, min(z[i - left], right - i))
                                    while i + z[i] &lt; len(s) and s[z[i]] == s[i + z[i]]:
                                        z[i] += 1
                                    if i + z[i] &gt; right:
                                        left, right = i, i + z[i]
                                return z
                        </code></pre>
                    </section>
                    <section>
                        <h4>Сложность алгоритма</h4>
                        <ul>
                            <li>Цикл <code data-trim class="python">for</code>, очевидно, выполняется $O(M)$ раз</li>
                            <li>Таким образом, нужно показать, что за все итерации цикла <code data-trim class="python">for</code> цикл <code data-trim class="python">while</code> тоже сделает $O(M)$ итераций</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Сложность алгоритма</h4>
                        <ul>
                            <li>В обоих случаях нашего алгоритма цикл <code data-trim class="python">while</code> либо вообще не выполнится, либо обязательно увеличит значение $r$</li>
                            <li>Т.к. значение $r$ никогда не уменьшается и не может быть больше $M$, цикл <code data-trim class="python">while</code> выполняет $O(M)$ итераций, а значит, сложность всего алгоритма: $$O(M)$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Применение $Z$-функции</h4>
                        <ul>
                            <li>Как уже упоминалось ранее, от значений <nobr>$Z$-функции</nobr> за $O(M)$ можно перейти к значениям $N_j$, необходимым для алгоритма Бойера-Мура</li>
                            <li>Для этого достаточно для каждого $j$ воспользоваться формулой $N_j(s) = Z_{M - j + 1}(s^r)$, где $s^r$ – обратная запись строки $s$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Применение $Z$-функции</h4>
                        <ul>
                            <li>Также от значений $Z_j$ мы можем перейти к значениям ${l'}_i$, воспользовавшись алгоритмом:</li>
                        </ul>
                        <pre><code data-trim class="python">
                            def Z2l_prime(Z):
                                l_prime = [0] * len(S)
                                longest = 0
                                for i, zv in enumerate(reversed(Z)):
                                    longest = max(zv, longest) if zv == i + 1 else longest
                                    l_prime[-i - 1] = longest
                                return l_prime
                        </code></pre>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Алгоритм Бойера-Мура</h4>
                        <ul>
                            <li>Теперь, когда все подготовительные этапы рассмотрены, можно очень просто сформулировать алгоритм Бойера-Мура</li>
                            <li>Для строки $t$ и подстроки $s$ необходимо сначала расположить $s$ под началом $t$, и далее выполнять просмотр с конца $s$, выбирая очередной сдвиг $s$ по тому из правил, которое даст наибольший результат</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Сложность</h4>
                        <ul>
                            <li>В такой постановке алгоритм Бойера-Мура в худшем случае работает за $O(M + N)$, чтобы найти первое вхождение подстроки</li>
                            <li>Однако при поиске всех вхождений сложность становится равной $O(M \cdot N)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Сложность</h4>
                        <ul>
                            <li>Такая плохая сложность достигается из-за того, что при обнаружении вхождения подстроки, когда сдвиг выполняется менее, чем на $M$, производится лишняя проверка символов, которые точно совпадают</li>
                            <li>Правило Галиля состоит в том, чтобы предотвратить такие проверки и позволяет достичь сложности $O(N + M)$ для поиска всех вхождений подстроки</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Заключительные замечания</h4>
                        <ul>
                            <li>Алгоритм Бойера-Мура стал предметом для множества исследований и оптимизаций и на данный момент практически не используется в своём изначальном варианте</li>
                            <li>Python использует алгоритм Бойера-Мура как часть реализации метода <code>find</code> класса <code>str</code></li>
                            <li>Для текстов на естественных языках алгоритм, как правило, работает с сублинейной скоростью и не достигает худшего случая</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li><b>EN</b> Dan Gusfield. Algorithms on Strings, Trees, and Sequences. Разделы 1, 2.1 и 2.2 – Подробнейшее изложение от автора $Z$-функции</li>
                            <li><b>EN</b> <a href='https://web.cs.ucdavis.edu/~gusfield/cs224f09/znotes.pdf'>Часть 1</a> из книги [1]</li>
                            <li><b>EN</b> <a href='https://web.cs.ucdavis.edu/~gusfield/cs224f09/bnotes.pdf'>Часть 2</a> из книги [1]</li>
                            <li><b>EN</b> <a href='https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm'>Описание</a> на Wikipedia с примерами на Python</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="5">
                            <li><b>RU</b> <a href='https://e-maxx.ru/algo/z_function'>Описание</a> более короткого варианта $Z$-функции</li>
                            <li><b>RU</b> <a href='https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D0%BE%D0%B9%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%9C%D1%83%D1%80%D0%B0'>Описание</a> на Wikipedia с альтернативной реализацией и примерами на C++</li>
                            <li><b>EN</b> <a href='https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm'>Визуализация</a> вычисления $Z$-функции</li>
                            <li><b>EN</b> <a href='https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm'>Описание</a> на Wikipedia с примерами на Python</li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>