<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>&laquo;Разделяй и властвуй&raquo;</h4>
                </section>
                <section>
                    <section>
                        <h4>Определение</h4>
                        <ul>
                            <li>Метод <b>&laquo;Разделяй и властвуй&raquo;</b> (или <b>Метод декомпозиции</b>) – один из наиболее простых подходов к разработке алгоритмов, который, тем не менее, зачастую позволяет создавать наиболее эффективные алгоритмы.</li>
                            <li>При данном подходе большая задача разбивается на несколько подзадач меньшего размера, каждая из которых так же рекурсивно разбивается до достижения базового случая. После этого решения маленьких подзадач собираются в решение изначальной задачи.</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример декомпозиции</h4>
                        <p>
                            <img src="04/Пример декомпозиции.png"  height="50%" width="50%">
                        </p>
                    </section>
                    <section>
                        <h4>Основные шаги</h4>
                        <p align="left">Общий принцип построения таких алгоритмов включает три шага:</p>
                        <ol>
                            <li><b>Разделение</b> задачи на несколько подзадач, которые представляют собой меньшие экземпляры той же задачи.</li>
                            <li><b>Властвование</b> над подзадачами путём их рекурсивного решения. Если подзадачи достаточно малы, они могут решаться непосредственно.</li>
                            <li><b>Комбинирование</b> решений подзадач в решение исходной задачи.</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Рекурсия</h4>
                        <ul>
                            <li>Декомпозиция естественным образом связана с понятием <b>рекурсии</b> – ситуацией, когда функция вызывает сама себя с другими аргументами</li>
                            <li>Чтобы рекурсия не была бесконечной, выделяют <b>базовый случай</b> – ситуацию, когда, вместо рекурсивного вызова самой себя, функция сразу выдаёт ответ</li>
                            <li>Как правило, базовый случай наступает, когда размер задачи достаточно мал для непосредственного решения</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример рекурсивного вычисления числа Фибоначчи</h4>
                        <pre><code data-trim class="python">
                            def fib(n):
                                # Базовый случай
                                if n == 1 or n == 2:
                                    return 1
                                # Рекурсивный вызов
                                return fib(n - 1) + fib(n - 2) 
                        </code></pre>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Сортировка слиянием</h4>
                        <ul>
                            <li>Отличным примером алгоритма, построенного по принципу &laquo;Разделяй и властвуй&raquo; является сортировка слиянием</li>
                            <li>Алгоритм принимает на вход массив $a$, а также индексы $p$ и $r$ – левую и правую границу сортируемой части массива соответственно</li>
                            <li>Слияние производится процедурой Merge из предыдущей лекции
                        </ul>
                    </section>
                    <section>
                        <h4>Сортировка слиянием</h4>
                        <p align="left">
                            <b>merge_sort(a, p, r):</b>
                        </p>
                        <ol>
                            <li>Если $p &lt; r$, выполнить:</li>
                            <ol>
                                <li>Вычислить $q = \lfloor \frac{p + r}{2} \rfloor$</li>
                                <li>Выполнить merge_sort(a, p, q)</li>
                                <li>Выполнить merge_sort(a, q + 1, r)</li>
                                <li>Слить фрагмент массива $a$ от $q$ до $r$ с серединой в $q$</li>
                            </ol>
                        </ol>
                    </section>
                    <section>
                        <h4>Этапы сортировки слиянием</h4>
                        <ul>
                            <li>Этап <b>разделения</b> включает расчёт среднего индекса $q$ и рекурсивный вызов алгоритма</li>
                            <li>Этап <b>властвования</b> заключается в рекурсивной работе алгоритма и отсутствии действий, когда достигнут базовый случай</li>
                            <li>Этап <b>комбинирования</b> состоит в слиянии результатов рекурсивных вызовов процедурой Merge
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ сортировки слиянием</h4>
                        <p align="left">
                            Сложность данного алгоритма, как и всех прочих алгоритмов с декомопзицией можно записать в виде <b>рекуррентного соотношения</b>:
                        </p>
                        $$
                            \begin{equation*}
                                T(N) = 
                                \begin{cases}
                                    c, при\ N = 1\\
                                    2T(\frac{N}{2}) + cN, при\ N &gt; 1
                                \end{cases}
                            \end{equation*}
                        $$
                    </section>
                    <section>
                        <h4>Анализ сортировки слиянием</h4>
                        <ul>
                            <li>$c$ в данном выражении означает некоторое константное время</li>
                            <li>Чтобы получить вычислительноую сложность в $O$-нотации, необходимо решить рекуррентное соотношение</li>
                            <li>Основной способ решения таких соотношений будет рассмотрен далее</li>
                            <li>В данный момент ограничимся другим – деревом рекурсии</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево рекурсии</h4>
                        <ul>
                            <li>Дерево рекурсии – древовидная структура, каждый узел в которой представляет собой один рекурсивный вызов</li>
                            <li>В каждом узле дерева записывается время, затрачиваемое на данный вызов, не считая времени работы следующих рекурсивных вызовов</li>
                            <li>Такие деревья позволяют удобно визуализировать рекурсивные алгоритмы и вычислять их сложность</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево рекурсии</h4>
                        <p>
                            <img src="03/rec_tree.png" height="70%" width="70%">
                        </p>
                    </section>
                    <section>
                        <h4>Анализ сортировки слиянием</h4>
                        <ul>
                            <li>На каждом уровне рекурсии выполняется вдвое больше рекурсивных вызовов, каждый из которых решает вдвое меньшую задачу</li>
                            <li>Таким образом, т.к. высота дерева равна $\lfloor log_2(N) \rfloor$, всего понадобится $cNlog_2(N) + cN$ операций</li>
                            <li>Тогда результирующая сложность составит $$O(Nlog_2(N))$$</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Общий вид рекуррентного соотношения</h4>
                        <p align="left">
                            Рекуррентные соотношения для большинства алгоритмов могут быть записаны в следующем общем виде:
                        </p>
                        $$T(N) = aT(\frac{N}{b}) + f(N)$$
                    </section>
                    <section>
                        <h4>Общий вид рекуррентного соотношения</h4>
                        <p align="left">
                            В приведённой формуле:
                            <ul>
                                <li>$a \geqslant 1$ – количество рекурсивных вызовов на каждом уровне</li>
                                <li>$b &gt; 1$ – количество подзадач, на которые бьётся текущая задача</li>
                                <li>$f(N)$ – время, необходимое на выполнение этапов разделения и слияния</li>
                            </ul>
                        </p>
                    </section>
                    <section>
                        <h4>Общий вид рекуррентного соотношения</h4>
                        <p align="left">
                            Пример для сортировки слиянием:
                        </p>
                        $$T(N) = 2T(\frac{N}{2}) + \Theta(N)$$
                        <p align="left">
                            Решение данного соотношения:
                        </p>
                        $$T(N) = log_b(N) \cdot f(N) = \Theta(Nlog_2(N))$$
                    </section>
                    <section>
                        <h4>Другие соотношения</h4>
                        <ul>
                            <li>Рассмотрим другие соотношения, чтобы понять, что позволяет приходить к такому решению</li>
                            <li>Для начала возьмём меньшую степень для $N$ в $f(N)$, т.е. пусть $f(N) = \Theta(N^0) = \Theta(1)$</li>
                            <li>Также примем $a = 1$ и $b = 2$</li>
                            <li>Построим дерево рекурсии</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево рекурсии</h4>
                        <p>
                            <img src="04/Визуализация a = 1, b = 2.png" height="65%" width="65%">
                        </p>
                    </section>
                    <section>
                        <h4>Анализ соотношения</h4>
                        <ul>
                            <li>В данном случае сложность алгоритма, заданного таким соотношением составит $log_2(N) \cdot \Theta(1) = \Theta(log_2(N))$</li>
                            <li>Примечательно, что это снова соответствует $log_b(N) \cdot f(N)$</li>
                            <li>Также отметим, что данное соотношение соответствует алгоритму двоичного поиска</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Другие соотношения</h4>
                        <ul>
                            <li>Рассмотрим ещё одно соотношение, теперь с большей степенью для $N$</li>
                            <li>Пусть $f(N) = \Theta(N^2)$</li>
                            <li>Также примем $a = 9$ и $b = 3$</li>
                            <li>Построим дерево рекурсии</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Дерево рекурсии</h4>
                        <p>
                            <img src="04/Недостроенная визуализация a = 9, b = 3.png">
                        </p>
                    </section>
                    <section>
                        <h4>Предварительный анализ дерева</h4>
                        <p align="left">
                            Как видно, не все величины на дереве известны. Выведем их:
                        </p>
                        <ul>
                            <li>Начнём с высоты дерева</li>
                            <li>На каждом уровне размер отдельной подзадачи уменьшается в $b$ раз</li>
                            <li>Тогда на $i$-ом уровне размер отдельной подзадачи равен $\frac{N}{b^i}$</li>
                            <li>Задачи бьются до тех пор, пока объём отдельной подзадачи не станет равен $1$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Предварительный анализ дерева</h4>
                        <p align="left">
                            Тогда: 
                            \begin{multline}
                                \frac{N}{b^h} = 1\\
                                N = b^h\\
                                h = log_b(N),
                            \end{multline}
                            где $h$ – высота дерева.
                        </p>
                    </section>
                    <section>
                        <h4>Предварительный анализ дерева</h4>
                        <ul>
                            <li>Теперь разберёмся с количеством листьев</li>
                            <li>На каждом уровне создаётся в $a$ раз больше рекурсивных вызовов</li>
                            <li>Тогда на $i$-ом уровне будет создано $a^i$ рекурсивных вызовов</li>
                            <li>Листья находятся на $h$-ом уровне, а значит их количество равно $a^h$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Предварительный анализ дерева</h4>
                        <p align="left">
                            Преобразуем, подставив значение $h$ и воспользовавшись свойством логарифмов:
                            $$a^h = a^{log_b(N)} = N^{log_b(a)}$$
                            Теперь, когда все пробелы закрыты, снова построим дерево.
                        </p>
                    </section>
                    <section>
                        <h4>Дерево рекурсии</h4>
                        <p>
                            <img src="04/Достроенная визуализация a = 9, b = 3.png">
                        </p>
                    </section>
                    <section>
                        <h4>Анализ соотношения</h4>
                        <ul>
                            <li>Проанализируем соотношение по дереву</li>
                            <li>Для начала посчитаем сумму сложности каждого уровня</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ соотношения</h4>
                        <ul>
                            <li>На первом уровне сложность, очевидно, равна $$f(N) = N^2$$</li>
                            <li>На втором уровне сложность равна $$9f(\frac{N}{3}) = 9(\frac{N}{3})^2 = 9\frac{N^2}{9} = N^2$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ соотношения</h4>
                        <ul>
                            <li>На третьем уровне сложность равна $$N^{log_b(a)}f(1) = N^{log_3(9)} \cdot 1 = N^2$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ соотношения</h4>
                        <ul>
                            <li>Как видно, для всех уровней сложность равна $$\Theta(N^2)$$</li>
                            <li>Как мы помним, всего таких уровней $$h + 1 = log_b(N) + 1$$</li>
                            <li>А значит, общая сложность равна $$(log_b(N) + 1) \cdot N^2 = \Theta(N^2log_b(N))$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ соотношения</h4>
                        <ul>
                            <li>Важно заметить, что мы снова получили сложность $T(N) = log_b(N) \cdot f(N)$</li>
                            <li>Следует выяснить, что именно позволяет нам сохранять это равенство на совершенно разных рекуррентных соотношениях</li>
                            <li>Рассмотрим подробнее значения каждого из элементов соотношения</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ соотношения</h4>
                        <table>
                            <tr>
                                <th>№</th>
                                <th>$a$</th>
                                <th>$b$</th>
                                <th>$f(N)$</th>
                            </tr>
                            <tr>
                                <td>1</td>
                                <td>$1$</td>
                                <td>$2$</td>
                                <td>$N^0$</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>$2$</td>
                                <td>$2$</td>
                                <td>$N^1$</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>$9$</td>
                                <td>$3$</td>
                                <td>$N^2$</td>
                            </tr>
                        </table>
                    </section>
                    <section>
                        <h4>Анализ соотношения</h4>
                        <ul>
                            <li>Методом пристального взгляда на таблицу можно убедиться, что во всех трёх случая соблюдается одно важнейнее соотношение: $$f(N) = N^d\\d = log_b(a)$$</li>
                            <li>Именно это соотношение позволяет сохранить хрупкий баланс, состоящий в том, что каждый уровень рекурсии вносит равный вклад в сложность</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Другие случаи</h4>
                        <ul>
                            <li>Посмотрим, что будет, если соотношение не соблюдается</li>
                            <li>Если $d &gt; log_b(a)$, каждый следующий уровень будет вносить всё меньший вклад в рекурсию, а значит, сложность будет определяться корнем дерева, то есть $$T(N) = f(N)$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Другие случаи</h4>
                        <ul>
                            <li>Если же $d &lt; log_b(a)$, каждый следующий уровень будет вносить всё больший вклад в рекурсию, а значит, сложность будет определяться суммой листьев дерева, то есть $$T(N) = N^{log_b(a)}$$</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Основная теорема</h4>
                        <ul>
                            <li>Всё, рассмотренное ранее, позволяет нам сформулировать так называемую <b>Основную теорему (Master theorem)</b> об асимптотических оценках для рекуррентных соотношений</li>
                            <li>Данная теорема требует соблюдения следующих предварительных условий:
                                <ol>
                                    <li>$T(N) = aT(\frac{N}{b}) + f(N)$</li>
                                    <li>$f(N) = \Theta(N^d)$</li>
                                    <li>$d \geqslant 0$</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Основная теорема</h4>
                        $$
                            \begin{equation*}
                                T(N) = 
                                \begin{cases}
                                    O(f(N)),&d &gt; log_b(a),\\
                                    O(N^{log_b(a)}),&d &lt; log_b(a),\\
                                    O(f(N) \cdot log_b(N)),&d = log_b(a).\\
                                \end{cases}
                            \end{equation*}
                        $$
                    </section>
                    <section>
                        <h4>Границы применимости</h4>
                        <ul>
                            <li>Как видно из предварительных условий, основная теорема применима только тогда, когда $f(N)$ – многочлен</li>
                            <li>Это наиболее распространённая ситуация, поэтому с помощью основной теоремы можно решить большинство соотношений</li>
                            <li>Если условие не выполняется, необходимо прибегнуть к непосредственному анализу дерева рекурсии и проверке полученного соотношения по индукции</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Задача о паре ближайших точек</h4>
                        <ul>
                            <li>Одной из задач, показываюших преимущество подхода &laquo;Разделяй и властвуй&raquo; является задача о паре ближайших точек</li>
                            <li>Дано: $N$ координат точек в двумерной системе координат: $(x_i, y_i), i = \overline{1, N}$</li>
                            <li>Найти: пару точек, декартово расстояние между которыми наименьшее</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Решение методом грубой силы</h4>
                        <ul>
                            <li>Простейший метод решения данной задачи – полный перебор всех возможных пар</li>
                            <li>Сложность такого решения: $$\Theta(C_N^2) = \Theta(N^2)$$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Решение методом декомпозиции</h4>
                        <ol>
                            <li>Провести вертикальную линию между точками так, чтобы по обе стороны от неё осталось равное количество точек</li>
                            <li>Пока количество точек больше $3$, рекурсивно проводить разбиение</li>
                            <li>Когда количество точек $\leqslant 3$, найти ближайшую пару методом грубой силы</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Решение методом декомпозиции</h4>
                        <ol start="4">
                            <li>Получив результаты от двух рекурсивных вызовов, найти среди них наименьшее расстояние $d_{min}$</li>
                            <li>Проверить все пары точек на расстоянии $d_{min}$ от разделительной линии</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Решение методом декомпозиции</h4>
                        <ul>
                            <li>На следующем слайде представлен пример с 9 точками от $A$ до $I$</li>
                            <li>Пунктирными линиями показано изначальное разбиение точек, в данном случае изображено два этапа рекурсии</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Шаги 1-2</h4>
                        <p>
                            <img src="04/Пара точек шаг 1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Решение методом декомпозиции</h4>
                        <ul>
                            <li>На следующем слайде красным цветом выделены точки, составляющие ближайшие пары в каждом из базовых случаев</li>
                            <li>Для первой (слева направо) секции это точки $E$ и $D$, для второй – $A$ и $B$, для третьей – $C$ и $F$, для четвёртой – $H$ и $I$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Шаг 3</h4>
                        <p>
                            <img src="04/Пара точек шаг 2.png">
                        </p>
                    </section>
                    <section>
                        <h4>Решение методом декомпозиции</h4>
                        <ul>
                            <li>На следующем слайде представлен пример объединения результатов двух рекурсивных вызовов</li>
                            <li>Наименьшее расстояние из полученных было между точками $A$ и $B$, они выделены красным, это расстояние принято в качестве $d_{min}$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Шаг 4</h4>
                        <p>
                            <img src="04/Пара точек шаг 3.png">
                        </p>
                    </section>
                    <section>
                        <h4>Решение методом декомпозиции</h4>
                        <ul>
                            <li>Полоса, в которой ведётся дальнейшая проверка, обозначена на следующем слайде линиями с более мелким пунктиром</li>
                            <li>Среди точек, попавших в полосу, а именно: $A$, $B$ и $C$, ближайшими являются $A$ и $C$, которые находятся по разные стороны от разделяющей линии</li>
                            <li>Точки $B$ и $C$ возвращаются в качестве решения</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Шаг 5</h4>
                        <p>
                            <img src="04/Пара точек шаг 5.png">
                        </p>
                    </section>
                    <section>
                        <h4>Замечания по реализации</h4>
                        <ul>
                            <li>Наибольший интерес для анализа такого алгоритма представляет случай, когда все точки "выстроены в столбик", т.е. их координаты по оси абсцисс совпадают</li>
                            <li>В таком случае не важно, где проводить разделительную линию, нужно просто разбить точки на группы, объём которых отличается не более, чем на 1</li>
                            <li>Однако тогда проверка точек, стоящих у границы, методом грубой силы займёт те же $O(N^2)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Оптимизации</h4>
                        <ul>
                            <li>Во-первых, можно идти от самой верхней точки к самой нижней (для этого понадобится отсортировать их по $y$-координате)</li>
                            <li>Во-вторых, можно показать, что для такого обхода достаточно на каждую точку просматривать не более 5 следующих</li>
                            <li>При таком подходе сложность каждой проверки снизится до $O(Nlog_2(N) + N) = O(Nlog_2(N))$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Оптимизации</h4>
                        <ul>
                            <li>Представленная на предыдущем слайде оптимизация позволит снизить сложность всего алгоритма до $O(N(log_2(N))^2)$</li>
                            <li>Однако, если сортировать базовые случаи и на каждом этапе рекурсии сливать результаты процедурой Merge, можно добиться сложности $O(Nlog_2(N))$</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Другие алгоритмы</h4>
                        <ul>
                            <li>По методу &laquo;Разделяй и властвуй&raquo; построено множество эффективных алгоритмов</li>
                            <li>Далее будут кратко описаны лишь некоторые из них</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Другие алгоритмы</h4>
                        <ul>
                            <li>Алгоритм Штрассена позволяет умножать квадратные матрицы со сложностью $O(N^{log_27})$, что эффективнее умножения по определению за $O(N^3)$</li>
                            <li>Алгоритм Карацубы позволяет перемножать <nobr>$N$-значные</nobr> целые числа со сложностью $O(N^{log_23})$, что эффективнее обычного умножения "в столбик" за $O(N^2)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Другие алгоритмы</h4>
                        <ul>
                            <li>Задача о поиске подмассива с максимальной суммой в массиве с отрицательными и положительными значениями с помощью метода декомпозиции решается за $O(Nlog_2(N))$, тогда как решение методом грубой силы занимает $O(N^2)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li>Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Раздел 2.3. Глава 4: введение и разделы 4.4, 4.5 – Основная книга нашего курса.</li>
                            <li>А.Левитин. Алгоритмы: введение в разработку и анализ. Глава 4: введение и раздел 4.6 – Более простая формулировка Основной теоремы и задача о паре ближайших точек</li>   
                            <li><a href='https://opendsa-server.cs.vt.edu/OpenDSA/Books/Everything/html/Mergesort.html'>Визуализация сортировки слиянием</a></li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="4">
                            <li>А. Скиена. Алгоритмы: руководство по разработке. Раздел 4.10 – Наиболее краткое и простое изложение материала</li>
                            <li><a href='https://youtu.be/-RPUtHZYXtY'>Альтернативное изложение материала</a> от преподавателя из МФТИ</li>
                            <li><a href='https://youtu.be/It6KagDmosY'>Альтернативное изложение материала</a> от другого преподавателя из МФТИ</li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>