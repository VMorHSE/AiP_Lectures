<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Двоичные деревья поиска</h4>
                </section>
                <section>
                    <section>
                        <h4>Постановка проблемы</h4>
                        <ul>
                            <li>На данный момент были рассмотрены смежные и связные структур данных</li>
                            <li>Часть из них позволяет быстрый поиск элементов (например, двоичный поиск в массиве)</li>
                            <li>Другие – быструю вставку (например, двусвязные списки)</li>
                            <li>Можно попробовать объединить эти преимущества</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Двоичный поиск в списке</h4>
                        <p align="left">
                            Чтобы получить быстрый двоичный поиск в связном списке, нужно, чтобы каждый его элемент хранил, помимо указателей на своих соседей, указатель на середины правой и левой половин списка
                        </p>
                        <p>
                            <img src="03/list_to_tree.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Двоичное дерево</h4>
                        <ul>
                            <li>Структурой данных, в наиболее удобном виде представляющей то, что было представлено на предыдущем слайде, является <b>двоичное дерево</b></li>
                            <li>Это связная структура данных, каждый элемент которой имеет три указателя: на узел-&laquo;родитель&raquo; и на своего правого и левого &laquo;потомка&raquo;</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Двоичное дерево</h4>
                        <p>
                            <img src="03/bt.png">
                        </p>
                    </section>
                    <section>
                        <h4>Параметры двоичного дерева</h4>
                        <ul>
                            <li>
                                В рамках данной лекции наиболее интересными для рассмотрения являются два параметра двоичного дерева:
                                <ol>
                                    <li>Количество узлов в дереве $N$</li>
                                    <li>Высота дерева $h$ – количество ветвей от корня до листа</li>
                                </ol>
                            </li>
                            <li>Данные параметры связаны соотношением $$h = \lfloor log_2(N) \rfloor $$</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Двоичное дерево поиска</h4>
                        <ul>
                            <li>Чтобы в представленной структуре можно было эффективно осуществлять поиск, оно должно удовлетворять правилу <b>двоичного дерева поиска (BST)</b>:</li>
                        </ul>
                        <p>Для каждого узла все элементы в его левом поддереве меньше него, а элементы в правом поддереве больше или равны ему</p>
                    </section>
                    <section>
                        <h4>Двоичное дерево поиска</h4>
                        <p>
                            <img src="03/bst.png">
                        </p>
                    </section>
                    <section>
                        <h4>Операции над BST</h4>
                        <p align="left">Для двоичного дерева поиска могут быть эффективно реализованы следующие операции:</p>
                        <ul>
                            <li>Обход элементов по возрастанию (или убыванию)</li>
                            <li>Поиск элемента по ключу</li>
                            <li>Поиск максимального и минимального элементов</li>
                            <li>Поиск следующего и предыдущего элемента (по возрастанию)</li>
                            <li>Вставка элемента в дерево</li>
                            <li>Удаление элемента из дерева</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Обход элементов</h4>
                        <ul>
                            <li>Чтобы обойти все элементы двоичного дерева поиска по возрастанию, необходимо для каждого из узлов обойти его левое поддерево, потом его собственный элемент и, наконец, правое поддерево</li>
                            <li>Под обходом поддерева понимается выполнение той же процедуры рекурсивно для поддерева</li>
                            <li>Сложность обхода дерева – $\Theta(N)$, т.к. для каждого узла процедура вызывается дважды: для его левого и правого поддерева</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Обход элементов</h4>
                        <p>
                            <img src="03/tracing.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Поиск min и max элементов</h4>
                        <ul>
                            <li>Благодаря свойству двоичного дерева поиска, минимальный и максимальный элементы всегда располагаются в самом левом и самом правом листе дерева соответственно</li>
                            <li>Сложность поиска максимального и минимального элементов – $O(h)$, т.к. посещённые при поиске узлы образуют <b>простой нисходящий путь</b>, т.е. каждый уровень дерева посещается один раз</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Поиск min и max элементов</h4>
                        <p>
                            <img src="03/min_max.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Поиск элемента по ключу</h4>
                        <p align="left">
                            Чтобы найти элемент с заданным ключом, в дереве выполняется следующий алгоритм:
                        </p>
                        <ol>
                            <li>Если значение в текущем узле равно искомому, вернуть текущий узел</li>
                            <li>Если искомое значение больше или равно текущему, продолжить поиск в правом поддереве</li>
                            <li>Если искомое значение меньше текущего, продолжить поиск в левом поддереве</li>
                            <li>Если встречено значение $NULL$, элемент не найден</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Поиск элемента по ключу</h4>
                        <p align="left">
                            Сложность поиска максимального и минимального элементов – $O(h)$, т.к. посещённые при поиске узлы образуют простой нисходящий путь
                        </p>
                    </section>
                    <section>
                        <h4>Поиск элемента по ключу</h4>
                        <p align="left">
                            Пунктирными стрелками на рисунке представлены пути обхода дерева для поиска элементов 8 (удачного) и 14 (неудачного).
                        </p>
                        <p>
                            <img src="03/search.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Вставка элемента в дерево</h4>
                        <ul>
                            <li>Для вставки элемента в дерево необходимо выполнить поиск элемента</li>
                            <li>В случае, если элемент нашёлся, следует продолжать поиск в правом поддереве</li>
                            <li>Когда встретится $NULL$, на его место нужно поставить вставляемый элемент</li>
                            <li>Аналогично рассмотренным ранее алгоритмам, сложность вставки элемента составляет $O(h)$, т.к. посещённые узлы образуют простой нисходящий путь</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Вставка элемента в дерево</h4>
                        <p align="left">
                            На данном слайде представлен поиск места для вставки элемента в дерево для существующего (7) и несуществующего (14) элементов
                        </p>
                        <p>
                            <img src="03/insert_1.png">
                        </p>
                    </section>
                    <section>
                        <h4>Вставка элемента в дерево</h4>
                        <p align="left">
                            На данном слайде представлено состояние дерева после вставки элементов 7 и 14
                        </p>
                        <p>
                            <img src="03/insert_2.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Удаление элемента из дерева</h4>
                        <ul>
                            <li>Удаление элемента из дерева является самым сложным алгоритмом, т.к. необходимо в любом случае сохранить свойство бинарного дерева поиска</li>
                            <li>Т.е. найти, какой узел нужно подставить на место удалённого и как отредактировать связи</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Удаление элемента из дерева</h4>
                        <ul>
                            <li>
                                При удалении могут возникнуть три ситуации:
                                <ol>
                                    <li>Удаляемый узел является листом (не имеет потомков)</li>
                                    <li>Удаляемый узел имеет только одного потомка</li>
                                    <li>Удаляемый узел имеет двух потомков</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Удаление листа</h4>
                        <p align="left">
                            В случае, если удаляемый узел является листом (не имеет потомков), он просто исключается из дерева, а на его место ставится $NULL$
                        </p>
                    </section>
                    <section>
                        <h4>Удаление с одним потомком</h4>
                        <p align="left">
                            Удаляемый узел $z$ имеет только левого потомка (для правого аналогично)
                        </p>
                        <p>
                            <img src="03/del__with_left.png" height="110%" width="110%">
                        </p>
                    </section>
                    <section>
                        <h4>Удаление с двумя потомками</h4>
                        <p align="left">
                            Когда удаляемый узел имеет двух потомков, возможны две подситуации:
                        </p>
                        <ol>
                            <li>Левый потомок его правого потомка равен $NULL$</li>
                            <li>Левый потомок его правого потомка не равен $NULL$</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Ситуация 1</h4>
                        <p>
                            <img src="03/del_with_two_1.png" height="110%" width="110%">
                        </p>
                    </section>
                    <section>
                        <h4>Ситуация 2</h4>
                        <p>
                            <img src="03/del_with_two_2.png">
                        </p>
                    </section>
                    <section>
                        <h4>Обобщение</h4>
                        <p align="left">
                            Обе ситуации можно обобщить одним правилом:
                        </p>
                        <ul>
                            <li>В случае удаления из дерева элемента, имеющего двух потомков, этот элемент заменяется наименьшим элементом его правого поддерева</li>
                            <li>При этом правый потомок этого наименьшего элемента становится левым потомком его родителя</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Обобщённое удаление</h4>
                        <p>
                            <img width="65%" height="65%" src="03/general_del.png">
                        </p>
                    </section>
                    <section>
                        <h4>Сложность удаления</h4>
                        <p align="left">
                            Вычислительная сложность удаления элемента из дерева в любом из случаев составляет $$O(h)$$
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Поиск предыдущего и следующего элемента</h4>
                        <p align="left">
                            Поиск следующего по возрастанию элемента учитывает два случая:
                        </p>
                        <ol>
                            <li>Если у переданного узла есть правое поддерево, в качестве следующего элемента возвращается наименьший элемент этого поддерева</li>
                            <li>Если правого поддерева нет, в качестве следующего элемента возвращается наименьший узел, левый потомок которого является родителем переданного</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Поиск предыдущего и следующего элемента</h4>
                        <ul>
                            <li>Поиск предыдущего элемента симметричен поиску следующего</li>
                            <li>Оба случая имеют сложность $O(h)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <ol>
                            <li>$next(8) = 10$, т.к. левый потомок $10$ – $7$ – является родителем для $8$</li>
                            <li>$next(10) = 13$, т.к. $13$ – наименьший элемент правого поддерева $10$</li>
                        </ol>
                        <p>
                            <img src="03/next.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Недостаток двоичных деревьев поиска</h4>
                        <ul>
                            <li>Двоичное дерево поиска представляет собой эффективную структуру данных, т.к. позволяет выполнять все операции за $$O(h) = O(log_2(N))$$</li>
                            <li>Но последнее равенство справедливо только для дерева, элементы в котором распределены по ветвям равномерно</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Недостаток двоичных деревьев поиска</h4>
                        <ul>
                            <li>Представим себе дерево (след. слайд), в которое последовательно добавляется $9$ узлов, содержащих значения по возрастанию от $1$ до $9$</li>
                            <li>В таком случае, очевидно, $h = N - 1$ и сложность всех операций снижается до $O(N)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Недостаток двоичных деревьев поиска</h4>
                        <p>
                            <img src="03/problem.png" height="80%" width="80%">
                        </p>
                    </section>
                    <section>
                        <h4>Недостаток двоичных деревьев поиска</h4>
                        <ul>
                            <li>Несмотря на то, что доказано [2], что в случае, когда все помещаемые в дерево величины равновероятны, дерево с наибольшей вероятностью будет заполняться равномерно, показанная ситуация тоже возможна</li>
                            <li>Эта проблема решается с помощью сбалансированных деревьев, которые будут рассмотрены на следующих лекциях</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li><b>RU</b> С. Скиена. Алгоиртмы. Руководство по разработке. 2-е издание. Подраздел 3.4 – Более простое и краткое объяснение.</li>
                            <li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 12 – Основная книга нашего курса.</li>                            
                            <li><b>RU</b> <a href='https://habr.com/ru/articles/267855/'>Статья</a> про BST</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="4">
                            <li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/BST.html?authuser=0'>Визуализация</a> BST</li>
                            <li><b>EN</b> <a href='https://visualgo.net/en/bst'>Более красивая визуализация</a> BST</li>
                            <li><b>RU</b> <a href='https://aliev.me/runestone/Trees/SearchTreeImplementation.html?authuser=0'>Пример реализации</a> BST на Python с подробным описанием</li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>