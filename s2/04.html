<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Двоичные пирамиды</h4>
                </section>
                <section>
                    <section>
                        <h4>Постановка проблемы</h4>
                        <ul>
                            <li><b>Очередь</b> (queue) – структура данных, которая активно используется при обработке некоторых запросов некоторым исполнителем</li>
                            <li>Например, программы выстраиваются в <b>очередь</b> в ожиданнии их выполнения процессором (CPU)</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Постановка проблемы</h4>
                        <ul>
                            <li>Однако в случае с процессором обычной очереди недостаточно, т.к. некоторые задачи, появившиеся позднее других, должны быть всё же выполнены раньше</li>
                            <li>К примеру, нажатый на клавиатуре символ должен быть отображён немедленно, а копирование очередного байта файла может и &laquo;подождать&raquo;</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Постановка проблемы</h4>
                        <ul>
                            <li>Подобные задачи приводят к необходимости присваивать каждому элементу очереди некоторое значение, отвечающее за степень &laquo;важности&raquo; данного элемента</li>
                            <li>Причём это значение должно непосредственно влиять на близость элемента к концу очереди – чем &laquo;важнее&raquo;, тем ближе к &laquo;выходу&raquo;</li>
                            <li>Также необходимо иметь возможность менять это значение для каждого элемента и, конечно, добавлять и удалять сами элементы</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Постановка проблемы</h4>
                        <ul>
                            <li>Таким образом, нам необходима структура данных, отвечающая на следующие запросы:
                                <ul>
                                    <li>Получить элемент с максимальным ключом – $get\_max()$</li>
                                    <li>Извлечь (удалить) элемент с максимальным ключом – $extract\_max()$</li>
                                    <li>Вставить новый элемент – $insert(key, val)$</li>
                                    <li>Изменить значение ключа для существующего элемента – $change\_key(ptr, new\_key)$</li>
                                </ul>
                            </li>                            
                        </ul>
                    </section>
                </section>                
                <section>
                    <section>
                        <h4>Терминология</h4>
                        <ul>
                            <li>В компьютерных науках значение, показывающее &laquo;важность&raquo; элемента в очереди, называют <b>приоритетом</b></li>
                            <li>Абстрактная структура данных, отвечающая на необходимые запросы, называется <b>очередь с приоритетами</b> (priority queue)</li>
                            <li>А древовидная структура, реализующая такую очередь, называется <b>двоичная пирамида</b> (binary heap)</li>
                        </ul>
                    </section>
                </section>                
                <section>
                    <section>
                        <h4>Двоичная пирамида</h4>
                        <ul>
                            <li><b>Двоичная</b> (бинарная) <b>пирамида</b> (куча) – binary heap – сбалансированное двоичное дерево, удовлетворяющее правилу пирамиды:</li>                            
                        </ul>
                        <p>Ключ каждого узла больше или равен ключам узлов-потомков</p>
                    </section>
                    <section>
                        <h4>Двоичная пирамида</h4>
                        <p>
                            <img src="04/bin_heap.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Вспомогательные операции</h4>
                        <ul>
                            <li>Для реализации двоичной пирамиды понадобятся ещё два алгоритма:
                                <ul>
                                    <li>$sift\_up$ – &laquo;просеять&raquo; элемент снизу вверх – используется, когда элемент внизу оказывается больше верхнего</li>
                                    <li>$sift\_down$ – &laquo;просеять&raquo; элемент сверху вниз – используется, когда элемент наверху оказывается меньше нижнего</li>
                                </ul>
                            </li>
                            <li>Оба алгоритма используются, чтобы поддерживать соответствие правилу пирамиды</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Просеивание вверх</h4>
                        <ul>
                            <li>Операция $sift\_up$ реализуется по следующему алгоритму: элемент меняется местами со своим родителем до тех пор, пока очередной родитель не будет больше него</li>
                            <li>Сложность алгоритма – $O(log_2(N))$</li>
                        </ul>
                        <p>
                            <img src="04/sift_up.png">
                        </p>
                    </section>
                    <section>
                        <h4>Просеивание вниз</h4>
                        <ul>
                            <li>Операция $sift\_down$ реализуется по следующему алгоритму: элемент меняется местами с большим из своих потомков до тех пор, пока оба потомка не будут меньше него</li>
                            <li>Сложность алгоритма – $O(log_2(N))$</li>
                        </ul>
                        <p>
                            <img src="04/sift_down.png">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Получение максимального элемента</h4>
                        <ul>
                            <li>$get\_max$ является наиболее очевидной операцией</li>
                            <li>Благодаря свойству двоичной пирамиды, для выполнения операции достаточно вернуть корень дерева</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Вставка нового элемента</h4>
                        <ul>
                            <li>Операция $insert$ выполняется в два шага:
                                <ol>
                                    <li>Элемент вставляется в дерево так, чтобы заполнение происходило сверху вниз слева направо</li>
                                    <li>Для вставленного элемента выполняется $sift\_up$</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Вставка нового элемента</h4>
                        <p>
                            <img src="04/insert.png">
                        </p>
                    </section>
                    <section>
                        <h4>Удаление максимального элемента</h4>
                        <ul>
                            <li>Операция $extract\_max$ выполняется в два шага:
                                <ol>
                                    <li>Последний элемент пирамиды (самый правый на самом нижнем уровне) становится на место корня</li>
                                    <li>Для нового корня выполняется $sift\_down$</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Удаление максимального элемента</h4>
                        <p>
                            <img src="04/extract_max.png">
                        </p>
                    </section>
                    <section>
                        <h4>Смена ключа</h4>
                        <ul>
                            <li>Операция $change\_key$ выполняется в два шага:
                                <ol>
                                    <li>Ключ указанного элемента меняется на нужное значение</li>
                                    <li>Для изменённого элемента выполняется $sift\_down$, если он меньше хотя бы одного из своих потомков и $sift\_up$, если он больше родителя</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Смена ключа</h4>
                        <p>
                            <img src="04/change_key.png">
                        </p>
                    </section>
                    <section>
                        <h4>Сложность основных операций</h4>
                        <table>
                            <tr>
                                <th>Операция</th> <th>Сложность</th>
                            </tr>
                            <tr>
                                <td>$get\_max$</td> <td>$O(1)$</td>
                            </tr>
                            <tr>
                                <td>$insert$</td> <td>$O(log_2(N))$</td>
                            </tr>
                            <tr>
                                <td>$extract\_max$</td> <td>$O(log_2(N))$</td>
                            </tr>
                            <tr>
                                <td>$change\_key$</td> <td>$O(log_2(N))$</td>
                            </tr>
                        </table>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Эффективная реализация</h4>
                        <ul>
                            <li>Двоичное дерево – достаточно компактная структура данных</li>
                            <li>Однако, т.к. она является связной, всегда имеют место накладные расходы на хранение указателей</li>
                            <li>Благодаря тому, что двоичная пирамида сбалансирована, её можно реализовать более эффективно по памяти – в виде массива</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Эффективная реализация</h4>
                        <ul>
                            <li>В таком массиве корневой элемент пирамиды будет иметь индекс $1$ (индексация с $1$)</li>
                            <li>Каждый из потомков $i$-ого элемента будет иметь индекс: $2i$ для левого и $2i + 1$ для правого потомка</li>
                            <li>Родитель $i$-ого элемента будет иметь индекс $\lfloor \frac{i}{2} \rfloor$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Эффективная реализация</h4>
                        <p>
                            <img src="04/effective_impl.png">
                        </p>
                    </section>
                    <section>
                        <h4>Повышение эффективности</h4>
                        <ul>
                            <li>Переход к правому потомку может быть заменён битовым сдвигом индекса данного элемента на $1$ влево (<code data-trim class="cpp">i &lt;&lt; 1</code>)</li>
                            <li>Переход к правому потомку может быть заменён битовым сдвигом индекса данного элемента на $1$ влево и побитовым ИЛИ с $1$:<br>(<code data-trim class="cpp">(i &lt;&lt; 1) | 1</code>)</li>
                            <li>Переход к родителю может быть заменён битовым сдвигом индекса данного элемента на $1$ вправо (<code data-trim class="cpp">i &gt;&gt; 1</code>)</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Пирамидальная сортировка</h4>
                        <ul>
                            <li>Помимо очереди с приоритетами, двоичная пирамида может быть использована для реализации эффективной сортировки массива</li>
                            <li>В простейшем виде пирамидальная сортировка выполняется следующим образом:
                                <ol>
                                    <li>Поместить все элементы неупорядоченного массива в двоичную пирамиду с помощью операции $insert$</li>
                                    <li>Заполнять массив с конца элементами, извлечёнными из пирамиды с помощью $get\_max$ и $extract\_max$</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пирамидальная сортировка</h4>
                        <ul>
                            <li>Сложность этапа $1$: $N$ вставок за $O(log_2(N))$ каждая $= O(Nlog_2(N))$</li>
                            <li>Сложность этапа $2$: $N$ получений максимума за $O(1)$ и извлечений за $O(log_2(N))$ каждое $=O(Nlog_2(N))$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Более эффективная реализация</h4>
                        <ul>
                            <li>Несмотря на то, что сложность представленного варианта пирамидальной сортировки по времени уже $O(Nlog_2(N))$, она требует $O(N)$ памяти для создания пирамиды из $N$ элементов</li>
                            <li>Чтобы сэкономить память, можно построить пирамиду прямо на том массиве, который сортируется</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Более эффективная реализация</h4>
                        <ul>
                            <li>Для построения пирамиды на месте понадобится дополнительная процедура $heapify$</li>
                            <li>Она состоит в применении $sift\_down$ поочерёдно для всех элементов, не являющихся листьями дерева, начиная с нижнего правого</li>
                            <li>Как доказано в [2], её сложность – $O(N)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Более эффективная реализация</h4>
                        <p align="left">
                            Более эффективная реализация пирамидальной сортировки состоит из следующих шагов:
                        </p>
                        <ol>
                            <li>Представление сортируемого массива как двоичной пирамиды</li>
                            <li>Выполнение $heapify$ над пирамидой за $O(N)$ для восстановления правила</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Продолжение</h4>
                        <ol start="3">
                            <li>
                                Повторение $N$ раз (пока в пирамиде есть элементы):
                                <ol>
                                    <li>Получение наибольшего элемента пирамиды с помощью $get\_max$ за $O(1)$</li>
                                    <li>Извлечение наибольшего элемента с помощью $extract\_max$ за $O(log_2(N))$</li>
                                    <li>Помещение извлечённого элемента в<br>$(N-i)$-ую ячейку сортируемого массива, где $i$ – номер текущей итерации, начиная с $0$, за $O(1)$</li>
                                </ol>
                            </li>                            
                        </ol>
                    </section>
                    <section>
                        <h4>Сложность эффективной реализации</h4>
                        <p>
                            $$O(N) + N(O(1) + O(log_2(N)) + O(1)) =\\
                            = O(N) + O(N) + O(Nlog_2(N)) + O(N) =\\
                            = 3O(N) + O(Nlog_2(N)) =\\
                            O(Nlog_2(N))$$
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Реализация в C++</h4>
                        <p align="left">В языке C++ очередь с приоритетами представлена контейнером <code data-trim class="cpp">std::priority_queue</code></p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li><b>RU</b> С. Скиена. Алгоиртмы. Руководство по разработке. 2-е издание. Подраздел 4.3 – Более простое и краткое объяснение.</li>
                            <li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 6 – Основная книга нашего курса.</li>                            
                            <li><b>RU</b> <a href='https://foxford.ru/wiki/informatika/kucha-heap?authuser=0&utm_referrer=https%3A%2F%2Fclassroom.google.com%2F'>Статья</a> про двоичные пирамиды на Фоксфорд</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="4">
                            <li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/Heap.html?authuser=0'>Визуализация</a> двоичной пирамиды</li>
                            <li><b>EN</b> <a href='https://visualgo.net/en/heap'>Более красивая визуализация</a> двоичной пирамиды</li>
                            <li><b>RU</b> <a href='https://acm.khpnets.info/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%D1%81_%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%B0%D0%BC%D0%B8?authuser=0'>Статья</a> про двоичные пирамиды с примером реализации на C++</li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>