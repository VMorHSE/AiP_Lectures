<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Простейшие структуры данных</h4>
                </section>
                <section>
                    <section>
                        <h4>Определение</h4>
                        <ul>
                            <li><b>Структура данных</b> (англ. <i style="font-style: italic">data structure</i>) — программная единица, позволяющая хранить и обрабатывать однотипные и/или логически связанные данные</li>
                            <li>Для добавления, поиска, изменения и удаления данных структура данных предоставляет некоторый набор функций, составляющих её интерфейс</li>
                            <li>Структуры данных описывают <b>способ хранения</b> однотипных данных вне зависимости от вида самих данных.</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Цель</h4>
                        <ul>
                            <li>Цель структур данных – упростить моделирование задач обработки данных</li>
                            <li>Большинство данных из практических задач может быть сведено к некоторым уже известным структурам данных</li>
                            <li>Это избавляет от необходимости разрабатывать новые алгоритмы для каждой новой задачи</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Виды структур данных</h4>
                        <p align="left">Структуры данных по реализации делятся на два вида:</p>
                        <ol>
                            <li><b>Смежные</b> структуры данных реализованы в виде непрерывных блоков памяти. К ним относятся массивы, матрицы, кучи и хэш-таблицы.</li>
                            <li><b>Связные</b> структуры данных реализованы в отдельных блоках памяти, связанных вместе с помощью указателей. К этому виду структур данных относятся списки, деревья и списки смежных вершин графов.</li>
                        </ol>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Массив</h4>
                        <ul>
                            <li>Массив представляет собой основную структуру данных смежного типа</li>
                            <li>Записи данных в массивах имеют постоянный размер, что позволяет с легкостью найти любой элемент по его индексу (или адресу)</li>
                            <li>Т.к. массив является смежным типом данных, его элементы располагаются в смежных ячейках памяти последовательно друг за другом</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Массив</h4>
                        <p align="left">Пример на C++:</p>
                        <pre><code data-trim class="cpp">
                            int arr[6] {10, 15, 16, 8, 9, 1};
                        </code></pre>
                        <p>
                            <img src="01/array.png" width="150%" height="150%">
                        </p>
                    </section>
                    <section>
                        <h4>Преимущества массива</h4>
                        <ul>
                            <li><b>Постоянное время доступа</b> при условии наличия индекса</li>
                            <li>Так как индекс каждого элемента массива соответствует определенному адресу в памяти, то при наличии соответствующего индекса доступ к произвольному элементу массива осуществляется практически мгновенно</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Преимущества массива</h4>
                        <ul>
                            <li><b>Эффективное использование памяти</b></li>
                            <li>Массивы содержат только данные, поэтому память не тратится на указатели и другую форматирующую информацию</li>
                            <li>Кроме этого, для элементов массива не требуется использовать метку конца записи, т. к. все элементы массива имеют одинаковый размер</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Преимущества массива</h4>
                        <ul>
                            <li><b>Локальность в памяти</b></li>
                            <li>Одна из самых распространенных идиом программирования — обработка элементов структуры данных в цикле</li>
                            <li>Массивы хорошо подходят для операций такого типа, поскольку обладают отличной локальностью в памяти</li>
                            <li>В современных компьютерных архитектурах физическая непрерывность последовательных обращений к данным помогает воспользоваться высокоскоростной кэш-памятью</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Вычислительная сложность</h4>
                        <ul>
                            <li>Массивы подразделяются на статические и динамические</li>
                            <li>Отличие динамических в том, что они допускают добавление элементов в конец</li>
                            <li>Таблица вычислительной сложности представлена для динамического массива</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Вычислительная сложность</h4>
                        <table>
                            <tr>
                                <th width="75%">Операция</th> <th>Вычислительная сложность</th>
                            </tr>
                            <tr>
                                <td width="75%">Получение по индексу</td> <td>$O(1)$</td>
                            </tr>
                            <tr>
                                <td width="75%">Вставка (или удаление) в начало</td> <td>$O(N)$</td>
                            </tr>
                            <tr>
                                <td width="75%">Вставка (или удаление) в середину</td> <td>$O(N)$</td>
                            </tr>
                            <tr>
                                <td width="75%">Вставка (или удаление) в конец</td> <td>$O(1)$ – амортизированная</td>
                            </tr>
                        </table>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Связный список</h4>
                        <ul>
                            <li>Связный список — базовая динамическая структура данных в информатике, состоящая из узлов, содержащих данные и ссылки («связки») на следующий и/или предыдущий узел списка</li>
                            <li>Т.к. каждый узел списка содержит указатель на следующий (т.е. адрес его расположения в памяти), элементы списка могут храниться в любых случайных местах в памяти независимо друг от друга</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Пример</h4>
                        <p align="left">
                            Для примера рассмотрим связный список из трёх элементов: $21$, $55$, $46$. Логически он выглядит так:
                        </p>
                        <p>
                            <img src="01/linked_list_logic.png">
                        </p>
                        <p align="left">
                            А в памяти может располагаться, например, так:
                        </p>
                        <p>
                            <img src="01/linked_list_memory.png">
                        </p>
                    </section>
                    <section>
                        <h4>Вычислительная сложность</h4>
                        <ul>
                            <li>Связные списки подразделяются на односвязные и двусвязные</li>
                            <li>В двусвязных каждый элемент указывает не только на следующий, но и на предыдущий</li>
                            <li>Временная сложность представлена для двусвязного списка</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Вычислительная сложность</h4>
                        <table>
                            <tr>
                                <th width="75%">Операция</th> <th>Вычислительная сложность</th>
                            </tr>
                            <tr>
                                <td width="75%">Получение по индексу</td> <td>$O(N)$</td>
                            </tr>
                            <tr>
                                <td width="75%">Вставка (или удаление) куда (откуда) угодно, если известен указатель</td> <td>$O(1)$</td>
                            </tr>
                        </table>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Абстрактные типы данных</h4>
                        <ul>
                            <li>Абстрактный тип данных (АТД) — это математическая модель для типов данных, где тип данных определяется поведением (семантикой) с точки зрения пользователя данных, а именно в терминах возможных значений, возможных операций над данными этого типа и поведения этих операций</li>
                            <li>Один и тот же абстрактный тип данных может быть реализован по-разному</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Абстрактные типы данных</h4>
                        <ul>
                            <li>Реализация описывается как набор других АТД и алгоритмов для каждой операции и называется структурой данных</li>
                            <li>Структура данных может быть реализована на выбранном языке программирования (в виде класса)</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Стек</h4>
                        <ul>
                            <li>Стек (Stack) – абстрактный тип данных, реализованный по принципу LIFO – Last In First Out – кто последним вошёл, тот первым вышел</li>
                            <li>
                                Интерфейс стека состоит из двух основных операций:
                                <ol>
                                    <li>$push$ – загрузить элемент в стек</li>
                                    <li>$pop$ – выгрузить элемент из стека</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Стек</h4>
                        <p>
                            <img src="01/stack.png" height="75%" width="75%">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Очередь</h4>
                        <ul>
                            <li>Очередь (Queue) – абстрактный тип данных, реализованный по принципу FIFO – First In First Out – кто первым вошёл, тот первым вышел</li>
                            <li>
                                Интерфейс очереди состоит из двух основных операций
                                <ol>
                                    <li>$enqueue$ – загрузить элемент в начало очереди</li>
                                    <li>$dequeue$ – выгрузить элемент с конца очереди</li>
                                </ol>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Очередь</h4>
                        <p>
                            <img src="01/queue.png" height="75%" width="75%">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Дек</h4>
                        <ul>
                            <li>Дек (Double-Ended Queue) – абстрактный тип данных, реализованный так же, как очередь, но с возможностью загрузки и выгрузки с обеих сторон</li>
                        </ul>
                        <p>
                            <img src="01/deque.png" height="75%" width="75%">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Реализация в C++</h4>
                        <table>
                            <tr>
                                <th>Структура</th> <th>Реализация</th>
                            </tr>
                            <tr>
                                <td>Динамический массив</td> <td><code data-trim class="cpp">std::vector</code></td>
                            </tr>
                            <tr>
                                <td>Односвязный список</td> <td><code data-trim class="cpp">std::forward_list</code></td>
                            </tr>
                            <tr>
                                <td>Двусвязный список</td> <td><code data-trim class="cpp">std::list</code></td>
                            </tr>
                            <tr>
                                <td>Стек</td> <td><code data-trim class="cpp">std::stack</code></td>
                            </tr>
                            <tr>
                                <td>Очередь</td> <td><code data-trim class="cpp">std::queue</code></td>
                            </tr>
                            <tr>
                                <td>Дек</td> <td><code data-trim class="cpp">std::deque</code></td>
                            </tr>
                        </table>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li>Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 10 – Основная книга нашего курса.</li>
                            <li>С. Скиена. Алгоиртмы. Руководство по разработке. 2-е издание. Разделы 3.1, 3.2 – Более простое и краткое объяснение.</li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>