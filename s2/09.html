<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Алгоритмизация и Программирование</h3>
					<div>&nbsp;</div>
					<h4>Морозов Владимир Игоревич</h4>
				</section>
				<section>
					<h4>Графы<br>Сильно связные компоненты и MST</h4>
				</section>			
				<section>
					<section>
						<h4>Определение сильно связного компонента</h4>
						<ul>
							<li><b>Сильно связный компонент</b> ориентированного графа – некоторое подмножество $C$ множества всех вершин $V$ графа $G$</li>
							<li>
								При этом для любой пары вершин $u$ и $v$ из $C$ выполняется:
								<ol>
									<li>$u$ достижима из $v$</li>
									<li>$v$ достижима из $u$</li>
								</ol>
							</li>
						</ul>
					</section>
					<section>
						<h4>Визуализация сильно связных компонентов</h4>
						<p align="left">
							На рисунке цветом выделены сильно связные компоненты
						</p>
						<p>
							<img src="09/ssc.png">
						</p>
					</section>
					<section>
						<h4>Разложение на сильно связные компоненты</h4>
						<ul>
							<li>Для выполнения разложения на сильно связные компоненты необходимо ввести операцию <b>транспонирования</b> графа – перенаправления всех его ребёр в обратную сторону</li>
							<li>Примечательно, что транспонирование не влияет на расположение сильно связных компонентов графа</li>
						</ul>
					</section>
					<section>
						<h4>Сильно связные компоненты транспонированного графа</h4>
						<p align="left">
							На рисунке представлен транспонированный граф с предыдущего слайда
						</p>
						<p>
							<img src="09/ssc_reversed.png">
						</p>
					</section>
					<section>
						<h4>Алгоритм разложения на сильно связные компоненты</h4>
						<ol>
							<li>Выполнить поиск в глубину на графе $G$</li>
							<li>Вычислить транспонированный граф $G^T$</li>
							<li>Выполнить поиск в глубину на графе $G^T$, однако при общем обходе просматривать его вершины в порядке убывания меток времени завершения $f$, полученных на шаге $1$</li>
							<li>Каждое дерево поиска в глубину из леса, полученного в результате выполнения шага $3$, считать сильно связным компонентом графа $G$</li>
						</ol>
					</section>
					<section>
						<h4>Сложность алгоримта</h4>
						<p align="left">
							Сложность алгоритма разложения на сильно связные компоненты:
						</p>
						$$\Theta(|V| + |E|)$$
					</section>
				</section>
				<section>
					<section>
						<h4>Взвешенный граф</h4>
						<p align="left">
							Граф $G = (V, E)$, в котором каждому ребру из множества $E$ поставлено в соответствие некоторое число $w$, называется <b>взвешенным</b>, а число $w$ называется <b>весом</b> ребра
						</p>
						<p>
							<img src="09/w_graph.png" width="70%" height="70%">
						</p>
					</section>
					<section>
						<h4>Весовая функция</h4>
						<ul>
							<li>Зададим функцию $w(u, v)$, определённую на множестве $E$ некоторого графа $G$, которая для каждого ребра из $E$, соединяющего вершины $u$ и $v$, будет возвращать его вес</li>
							<li>
								Также примем, что значение функции $w$ от некоторого множества рёбер $T$ будет равно суммарному весу этих рёбер:
								$$w(T) = \sum_{(u, v) \in T} w(u, v)$$
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Минимальное остовное дерево</h4>
						<ul>
							<li>Пусть для графа $G = (V, E)$ необходимо найти ациклическое подмножество рёбер $T \subseteq E$, которые соединяют все вершины и при этом вес $w(T)$ минимален среди всех подмножеств $E$, соединяющих все вершины</li>
							<li>Такая задача называется задачей поиска <b>минимального остовного дерева</b>, а её решение – множество рёбер $T$ – <b>минимальным остовным деревом</b> (minimum spanning tree, MST)</li>
						</ul>
					</section>
					<section>
						<h4>Минимальное остовное дерево</h4>
						<p align="left">
							На рисунке тройной линией выделены рёбра, входящие в MST
						</p>
						<p>
							<img src="09/mst.png">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Обобщённый алгоритм построения MST</h4>
						<ul>
							<li>Обобщённый алгоритм &laquo;выращивания&raquo; минимального остовного дерева работает с множеством рёбер $A$</li>
							<li>На каждом шаге алгоритма $A$ является подмножеством результирующего дерева $T$</li>
						</ul>
					</section>
					<section>
						<h4>Обобщённый алгоритм построения MST</h4>
						<ul>
							<li>На каждом шаге алгоритма к $A$ добавляется <b>безопасное ребро</b></li>
							<li>
								<b>Безопасное ребро</b> – такое ребро $(u, v) \in E$, добавление которого к $A$ оставляет $A$ подмножеством $T$:
								$$(A \cup \{(u, v)\}) \subseteq T$$
							</li>
						</ul>
					</section>
					<section>
						<h4>Обобщённый алгоритм построения MST</h4>
						<ol>
							<li>Сделать $A$ пустым множеством</li>
							<li>
								Пока $A$ не стало остовным деревом (т.е. не соединило все вершины):
								<ol>
									<li>Найти ребро $(u, v)$, безопасное для $A$</li>
									<li>Добавить ребро $(u, v)$ к $A$</li>
								</ol>
							</li>
							<li>Вернуть $A$ в качестве минимального остовного дерева</li>
						</ol>
					</section>
				</section>
				<section>
					<section>
						<h4>Проблема обобщённого алгоритма</h4>
						<ul>
							<li>Обобщённый алгоритм представляет только общий подход и не решает наиболее сложную задачу – поиск ребра, безопасного для $A$</li>
							<li>Для поиска безопасного ребра необходимо ввести ряд определений</li>
						</ul>
					</section>
					<section>
						<h4>Разрезы</h4>
						<ul>
							<li><b>Разрезом</b> некоторого неориентированного графа $G$ называется разбиение множества его вершин $V$ на пару множеств $(S, V - S)$</li>
							<li>Ребро $(u, v)$ <b>пересекает</b> разрез $(S, V - S)$, если один из его концов находится в множестве $S$, а другой – в $V - S$</li>
						</ul>
					</section>
					<section>
						<h4>Разрезы</h4>
						<ul>
							<li>Разрез <b>согласован</b> с множеством рёбер $A$, если ни одно ребро из $A$ не пересекает этот разрез</li>
							<li>Ребро, пересекающее разрез, называется <b>лёгким</b>, если оно имеет минимальный вес среди всех рёбер, пересекающих разрез</li>
						</ul>
					</section>
					<section>
						<h4>Визуализация разреза</h4>
						<p align="left">
							На рисунке красным выделена линия разреза, пунктиром обозначено лёгкое ребро
						</p>
						<p>
							<img src="09/cut.png" width="80%" height="80%">
						</p>
					</section>
					<section>
						<h4>Правило распознавания безопасных рёбер</h4>
						<ul>
							<li>Пусть $(S, V - S)$ – любой разрез $G$, согласованный с множеством $A$</li>
							<li>А $(u, v)$ – лёгкое ребро, пересекающее этот разрез</li>
							<li>Тогда ребро $(u, v)$ является безопасным ребром для $A$</li>
						</ul>
					</section>
					<section>
						<h4>Уточнение обобщённого алгоритма</h4>
						<ul>
							<li>В любой момент работы обобщённого алгоритма граф $G_A = (V, A)$ представляет собой лес &laquo;мини-деревьев&raquo;, в каждом из которых может быть $1$ вершина (в начале работы) или больше</li>
							<li>Каждое такое дерево – связный компонент в $G_A$</li>
						</ul>
					</section>
					<section>
						<h4>Следствие</h4>
						<ul>
							<li>Пусть $C = (V_C, E_C)$ – связный компонент в лесу $G_A = (V, A)$</li>
							<li>Если $(u, v)$ – лёгкое ребро, соединяющее $C$ с другим связным компонентом $G_A$, то оно безопасно для $A$</li>
							<li>Это следствие используется реализациями обобщённого алгоритма</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Алгоритм Крускала</h4>
						<ul>
							<li>Алгоритм Крускала – один из распространённых алгоритмов построения MST</li>
							<li>На каждом шаге своей работы он добавляет к $A$ минимальное ребро, соединяющее два дерева в лесу $G_A$</li>
							<li>Для реализации алгоритма введём ряд непересекающихся множеств $S_i, i = 1..|V|$, каждое из которых может хранить некоторые вершины из $V$</li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм Крускала (начало)</h4>
						<ol>
							<li>Сделать $A$ пустым множеством</li>
							<li>В каждое из множеств $S_i$ поместить по одной вершине из $V$</li>
							<li>Отсортировать рёбра из $E$ по неубыванию их веса</li>
						</ol>
					</section>
					<section>
						<h4>Алгоритм Крускала (продолжение)</h4>
						<ol start="4">
							<li>
								Для каждого ребра $(u, v) \in E$:
								<ol>
									<li>
										Если вершины $u$ и $v$ не входят в одно и то же множество $S_i$:
										<ol>
											<li>Добавить ребро $(u, v)$ к $A$</li>
											<li>Объединить множества, содержащие вершины $u$ и $v$, в одно</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>Вернуть $A$ как минимальное остовное дерево</li>
						</ol>
					</section>
				</section>
				<section>
					<section>
						<h4>Алгоритм Прима</h4>
						<ul>
							<li>Алгоритм Прима – ещё один распространённый алгоритм построения MST</li>
							<li>Он строит одно дерево, т.е. все деревья в лесу $G_A$, кроме одного, содержат по одной вершине</li>
						</ul>
					</section>
					<section>
						<h4>Дополнительные атрибуты</h4>
						<p align="left">
							Для реализации алгоритма Прима каждой вершине назначаются дополнительные свойства:
						</p>
						<ul>
							<li>$key$ – минимальный вес ребра из всех рёбер, соединяющих данную вершину с любой из вершин строящегося дерева (если таких рёбер нет, $key = \infty$)</li>
							<li>$p$ – родитель данной вершины в строящемся дереве (если вершина ещё не входит в дерево, свойство равно $NULL$)</li>
						</ul>
					</section>
					<section>
						<h4>Очередь с приоритетами</h4>
						<ul>
							<li>Также в реализации алгоритма используется невозрастающая очередь с приоритетами $Q$</li>
							<li>$Q$ содержащит все вершины, которые ещё не вошли в дерево</li>
							<li>В качестве приоритета $Q$ использует значение $key$</li>
						</ul>
					</section>
					<section>
						<h4>Входные данные</h4>
						<p align="left">
							Алгоритм принимает на вход, помимо графа $G$, некоторую вершину $r$, которая станет корнем результирующего минимального остовного дерева
						</p>
					</section>
					<section>
						<h4>Алгоритм Прима (начало)</h4>
						<ol>
							<li>Всем вершинам из $V$ установить значение $key = \infty$, а $p = NULL$</li>
							<li>Значение $key$ для вершины $r$ установить $= 0$</li>
							<li>Поместить все вершины из $V$ в очередь $Q$</li>
						</ol>
					</section>
					<section>
						<h4>Алгоритм Прима (продолжение)</h4>
						<ol start="4">
							<li>
								Пока очередь $Q$ не пуста:
								<ol>
									<li>Извлечь верхний элемент из $Q$ в переменную $u$</li>
									<li>
										Для каждой вершины $v$, смежной с $u$:
										<ol>
											<li>
												Если $v$ есть в очереди $Q$ и $w(u, v) &lt;$ атрибута $key$ для $v$:
												<ol>
													<li>Сделать $u$ родителем $v$ в дереве (установить $p$ для $v$ равным $u$)</li>
													<li>Атрибуту $key$ для $v$ присвоить значение $w(u, v)$ и обновить очередь $Q$</li>
												</ol>
											</li>
										</ol>
									</li>
								</ol>
							</li>
						</ol>
					</section>
				</section>
				<section>
					<section>
						<h4>Сложность работы алгоритмов</h4>
						<p align="left">
							Временная сложность работы алгоритма Крускала:
							$$O(Elog_2V)$$
						</p>
						<p align="left">
							Временная сложность работы алгоритма Прима:
							$$O(Elog_2V)$$
						</p>
					</section>
				</section>
				<section>
					<h4>Полезные источники</h4>
					<ol>
						<li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Главы 22-23.</li>
						<li><b>RU</b> С. Скиена. Алгоиртмы. Руководство по разработке. 2-е издание. Разделы 5.10.2, 6.1 – Более простое и краткое объяснение.</li>
						<li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/Kruskal.html'>Визуализация</a> алгоритма Крускала</li>
						<li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/Prim.html'>Визуализация</a> алгоритма Прима</li>
						<li><b>EN</b> <a href='https://visualgo.net/en/mst'>Более красивая визуализация</a> алгоритмов Крускала и Прима</li>
					</ol>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>