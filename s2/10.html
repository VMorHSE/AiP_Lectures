<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Алгоритмизация и Программирование</h3>
					<div>&nbsp;</div>
					<h4>Морозов Владимир Игоревич</h4>
				</section>
				<section>
					<h4>Графы<br>Поиск кратчайших путей</h4>
				</section>			
				<section>
					<section>
						<h4>Кратчайший путь</h4>
						<ul>
							<li>Пусть есть некоторый взвешенный граф<br>$G = (V, E)$</li>
							<li>
								За <b>путь</b> на таком графе обозначим последовательность связанных вершин:
								$$ p = \langle v_0, v_1, ..., v_k \rangle, v_i \in V $$
							</li>
						</ul>
					</section>
					<section>
						<h4>Кратчайший путь</h4>
						<ul>
							<li>Имея весовую функцию $w$, возвращающую суммарную длину всех рёбер на таком пути, можно определить вес кратчайшего пути между вершинами $u$ и $v$:
								$$ \delta(u, v) =
								\begin{cases}
									min\{w(p)\}, & \text{если}\ \exists p: u \rightsquigarrow v\ \text{через}\ p, \\
									\infty, & \text{иначе},
								\end{cases}
								$$
							</li>
							<li>Тогда любой путь $p$ между вершинами $v$ и $u$, чей вес равен весу кратчайшего пути между ними, – кратчайший путь между этими вершинами</li>
						</ul>
					</section>
				</section>				
				<section>
					<section>
						<h4>Циклы</h4>
						<ul>
							<li>Циклом на ориентированном графе называется такой путь, по которому из одной вершины можно вернуться в неё же</li>
							<li>Весом цикла называется сумма весов всех рёбер, включённых в такой путь</li>
							<li>Если при поиске кратчайшего пути в графе встречается цикл с отрицательным весом, то длина кратчайшего пути не определена, т.к., проходя по циклу, можно бесконечно уменьшать такой путь</li>
						</ul>
					</section>
					<section>
						<h4>Циклы с отрицательным весом</h4>
						<p align="left">
							Вес цикла на рисунке  $= –3$
						</p>
						<p>
							<img src="10/cycle.png">
						</p>
					</section>
				</section>				
				<section>
					<section>
						<h4>Общие принципы поиска кратчайшего пути</h4>
						<ul>
							<li>Все алгоритмы поиска кратчайшего пути получают на вход <b>исток</b> – некоторую вершину<br>$s$, для которой и будут найдены кратчайшие пути до всех остальных вершин графа</li>
							<li>Одним из результатов работы алгоритма является маркировка всех вершин $v_i$ значениями $\delta(s, v_i)$ – длинами кратчайших путей от истока до них</li>
						</ul>
					</section>
					<section>
						<h4>Общие принципы поиска кратчайшего пути</h4>
						<ul>
							<li>Чтобы корректно расставить такую маркировку, каждому узлу присваивается атрибут $d$ – верхняя граница значения кратчайшего пути от истока к нему</li>
							<li>Этот атрибут пересчитывается в процессе работы алгоритма до тех пор, пока не станет равен искомому значению $\delta(s, v_i)$</li>
						</ul>
					</section>
					<section>
						<h4>Общие принципы поиска кратчайшего пути</h4>
						<ul>
							<li>Для построения путей каждой вершине присваивается атрибут $\pi$ – указатель на вершину, которая предшествует данной на кратчайшем пути от истока до неё</li>
						</ul>
					</section>
					<section>
						<h4>Общая инициализация</h4>
						<p align="left">
							Перед началом работы каждого из алгоритмов используется общий алгоритм инициализации:
						</p>
						<ol>
							<li>
								Для каждой вершины $v \in V$:
								<ol>
									<li>Атрибуту $d$ вершины $v$ присвоить значение $\infty$</li>
									<li>Атрибуту $\pi$ вершины $v$ присвоить значение $NULL$</li>
								</ol>
							</li>
							<li>Атрибуту $d$ истока $s$ присвоить значение $0$</li>
						</ol>
					</section>
				</section>				
				<section>
					<section>
						<h4>Ослабление ребра</h4>
						<ul>
							<li>Для пересчёта атрибутов $d$ с целью получения искомого значения кратчайшего пути все алгоритмы используют <b>ослабление</b></li>
							<li><b>Ослабление ребра</b> – это проверка возможности улучшения кратчайшего пути между вершинами $s$ и $v$ путём проведения его через смежную с $v$ вершину $u$</li>
							<li>В случае наличия такой возможности она реализуется</li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм ослабления ребра</h4>
						<ol>
							<li>
								Если $v.d &gt; u.d + w(u, v)$:
								<ol>
									<li>Присвоить $v.d = u.d + w(u, v)$</li>
									<li>Присвоить $v.\pi = u$</li>
								</ol>
							</li>
						</ol>
						<p align="left">
							Таким образом, проверяется существование более подходящей кандидатуры для предшествования данной вершине на кратчайшем пути и, если такой кандидат находится, он заменяет текущего предшественника
						</p>
					</section>
					<section>
						<h4>Ослабление ребра</h4>
						<p>
							<img src="10/lightening.png">
						</p>
					</section>
				</section>				
				<section>
					<section>
						<h4>Свойства кратчайших путей и ослабления</h4>
						<p align="left">
							При построении алгоритмов поиска кратчайших путей используются некоторые свойства кратчайших путей и операции ослабления:
						</p>
						<ol>
							<li><b>Неравенство треугольника:</b><br>Для каждого ребра $(u, v) \in E$ выполняется неравенство $\delta(s, v) \leqslant \delta(s, u) + w(u, v)$</li>
						</ol>
					</section>
					<section>
						<h4>Свойства кратчайших путей и ослабления</h4>
						<ol start="2">
							<li><b>Свойство верхней границы:</b><br>Для всех вершин $v \in V$ всегда выполняется неравенство $v.d \geqslant \delta(s, v)$, а после того как величина $v.d$ достигает значения $\delta(s, v)$, она больше не изменяется</li>
							<li><b>Свойство отсутствия пути:</b><br>Если из вершины $s$ в вершину $v$ нет пути, то всегда выполняется соотношение<br>$v.d = \delta(s, v) = \infty$</li>
						</ol>
					</section>
					<section>
						<h4>Свойства кратчайших путей и ослабления</h4>
						<ol start="4">
							<li><b>Свойство сходимости:</b><br>Если $s \rightsquigarrow u \rightarrow v$ является кратчайшим путём в $G$ для некоторых $u, v \in V$ и если<br>$u.d = \delta(s, u)$ в любой момент до ослабления ребра $(u, v)$, то $v.d = \delta(s, v)$ в любой момент после этого</li>
						</ol>
					</section>
					<section>
						<h4>Свойства кратчайших путей и ослабления</h4>
						<ol start="5">
							<li><b>Свойство ослабления пути:</b><br>Если $p = \langle v_0, v_1, ..., v_k \rangle$ является кратчайшим путём из $s = v_0$ в $v_k$ и если мы ослабляем рёбра $p$ в порядке $(v_0, v_1)$, $(v_1, v_2)$, $...$, $(v_{k - 1}, v_k)$, то $v_k.d = \delta(s, v_k)$. Это свойство выполняется независимо от других этапов ослабления, даже если они чередуются с ослаблением рёбер, принадлежащих пути $p$.</li>
						</ol>
					</section>
					<section>
						<h4>Свойства кратчайших путей и ослабления</h4>
						<ol start="6">
							<li><b>Свойство подграфа предшествования:</b><br>Если для всех вершин $v \in V$ выполняется $v.d = \delta(s, v)$, то подграф предшествования представляет собой дерево кратчайших путей с корнем в истоке $s$</li>
						</ol>
					</section>
				</section>
				<section>
					<section>
						<h4>Алгоритм Беллмана-Форда</h4>
						<ul>
							<li>Алгоритм Беллмана-Форда ищет кратчайший путь в общем случае: когда граф может содержать в том числе и отрицательные рёбра</li>
							<li>Также алгоритм обнаруживает факт наличия циклов с отрицательным весом</li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм Беллмана-Форда</h4>
						<ol>
							<li>Инициализировать граф для поиска кратчайших путей</li>
							<li>
								$|V| - 1$ раз повторять:
								<ol>
									<li>Ослабить каждое ребро $(u, v)$ в графе</li>
								</ol>
							</li>
							<li>
								Для каждого ребра $(u, v)$ в графе:
								<ol>
									<li>Если $v.d &gt; u.d + w(u, v)$, закончить выполнение с ошибкой (найден цикл с отрицательным весом)</li>
								</ol>
							</li>
							<li>Закончить выполнение</li>
						</ol>
					</section>
					<section>
						<h4>Анализ алгоритма</h4>
						<ul>
							<li>Алгоритм Беллмана-Форда представляет собой наиболее простой способ применения операций ослабления</li>
							<li>Временная сложность работы алгоритма составляет:</li>							
						</ul>
						$$ O(VE) $$
					</section>
					<section>
						<h4>Корректность алгоритма</h4>
						<ul>
							<li>Т.к. кратчайший путь между любой парой вершин является простым, он содержит не более $|V| - 1$ рёбер</li>
							<li>На каждой $i$-ой итерации алгоритма ослабляются все $|E|$ рёбер, а значит, среди них точно есть ребро $i$-е ребро кратчайшего пути</li>							
							<li>Тогда, согласно свойству ослабления пути, атрибут $d$ последней вершины в пути будет равен кратчайшему пути от истока до неё</li>							
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Поиск кратчайшего пути на ациклическом графе</h4>
						<ol>
							<li>Выполнить топологическую сортировку вершин графа</li>
							<li>Инициализировать граф для поиска кратчайших путей</li>							
							<li>
								Для каждой вершины $u$ в порядке топологической сортировки:
								<ol>
									<li>Для каждой вершины $v$, смежной с $u$: Ослабить ребро $(u, v)$</li>
								</ol>
							</li>							
						</ol>
					</section>
					<section>
						<h4>Анализ алгоритма</h4>
						<ul>
							<li>Этот и следующий алгоритмы решают задачу поиска кратчайшего пути только для какого-то частного случая графа</li>
							<li>Данный алгоритм работает только с ациклическими графами</li>							
							<li>Временная сложность данного алгоритма – $\Theta(V + E)$, т.к. топологическая сортировка работает за $O(V + E)$, инициализация – за $O(V)$, а благодаря ацикличности графа, на шаге $3$ производится ровно $|E|$ ослаблений</li>							
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Алгоритм Дийкстры</h4>
						<ul>
							<li>Алгоритм Дийкстры ищет кратчайшие пути в графе без отрицательных рёбер</li>
							<li>
								Для работы данного алгоритма вводится две дополнительный структуры данных:
								<ol>
									<li>Множество вершин $S$, для которых уже вычислены веса кратчайших путей</li>
									<li>Очередь с приоритетами $Q$, содержащая вершины и использующая в качестве ключа атрибут $d$</li>
								</ol>
							</li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм Дийкстры</h4>
						<p align="left">
							Суть работы данного алгоритма состоит в последовательном добавлении вершин, для которых значение $d$ минимально, из множества $V - S$ в множество $S$ и ослаблении всех выходящих из очередной вершины рёбер
						</p>
					</section>
					<section>
						<h4>Алгоритм Дийкстры</h4>
						<ol>
							<li>Инициализировать граф для поиска кратчайших путей</li>
							<li>Сделать $S$ пустым множеством</li>							
							<li>Поместить в очередь $Q$ все вершины графа</li>							
							<li>
								Пока очередь $Q$ не пуста:
								<ol>
									<li>Извлечь элемент $u$ из очереди $Q$ и поместить его в множество $S$</li>
									<li>
										Для каждой вершины $v$, смежной с $u$:
										<ol>
											<li>Ослабить ребро $(u, v)$</li>
											<li>Обновить ключи вершины $v$ в очереди $Q$</li>
										</ol>
									</li>
								</ol>
							</li>							
						</ol>
					</section>
					<section>
						<h4>Анализ алгоритма</h4>
						<ul>
							<li>В общем случае $(|E| \approx |V|^2)$ временная сложность работы алгоритма равна $O(V^2)$</li>
							<li>Однако для разреженного графа $(|E| \approx |V|)$ сложность можно улучшить до $O(Vlog_2(V) + E)$</li>					
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Полезные источники</h4>
						<ol>
							<li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 24: начало и разделы 24.1, 24.2 и 24.3.</li>
							<li><b>RU</b> С. Скиена. Алгоиртмы. Руководство по разработке. 2-е издание. Разделы 6.3, 6.3.1 – Более простое и краткое объяснение.</li>
							<li><b>RU</b> <a href='https://drive.google.com/file/d/1gNDB8DrIa2O-w9zap70QDWnIRh5BL1Z5/view'>Альтернативная презентация</a> от преподавателя из Новосибирска</li>
						</ol>
					</section>
					<section>
						<h4>Полезные источники</h4>
						<ol start="4">
							<li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html'>Визуализация</a> алгоритма Дийкстры</li>
							<li><b>EN</b> <a href='https://visualgo.net/en/sssp'>Более красивая визуализация</a> алгоритмов Беллмана-Форда и Дийкстры</li>
						</ol>
					</section>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>