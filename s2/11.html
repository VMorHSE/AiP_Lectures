<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Алгоритмизация и Программирование</h3>
					<div>&nbsp;</div>
					<h4>Морозов Владимир Игоревич</h4>
				</section>
				<section>
					<h4>Классы сложности $P$ и $NP$</h4>
				</section>
				<section>
					<section>
						<h4>Постановка проблемы</h4>
						<ul>
							<li>Существует ряд задач, для которых поиск эффективного обобщённого алгоритма решения, скорее всего, является пустой тратой времени</li>
							<li>Для таких задач, как правило, более полезным будет найти приближённое решение или решение для частного случая</li>
							<li>Чтобы доказать, что задача является таковой, вводятся классы сложности</li>
						</ul>
					</section>
					<section>
						<h4>Класс сложности $P$</h4>
						<ul>
							<li>Класс сложности $P$ содержит наиболее простые задачи, а именно, задачи, решаемые за полиномиальное время</li>
							<li>Более формально: задача принадлежит классу $P$, если существует алгоритм, решающий её за время $O(N^k)$, где $N$ — объём задачи, $k$ — некоторая константа</li>
							<li>К этому классу относится большинство рассмотренных нами задач</li>
						</ul>
					</section>
					<section>
						<h4>Почему именно полином</h4>
						<ul>
							<li>В теории легко представить задачу, решаемую за полиномиальное время, но при этом являющуюся достаточно сложной</li>
							<li>К примеру, задача, решаемая алгоритмом за время $O(N^{100})$ относится к классу $P$, однако, очевидно, не является вычислительно простой</li>
							<li>Однако на практике подобные задачи встречаются крайне редко</li>
							<li>Как правило, степень полинома не превосходит $3$</li>
						</ul>
					</section>
					<section>
						<h4>Почему именно полином</h4>
						<ul>
							<li>Более того, практика показывает, что, даже если на данный момент алгоритм решения задачи работает за полином степени больше $3$, скорее всего, в скором времени будет найден гораздо более эффективный алгоритм</li>
							<li>Сумма и перемножение полиномов, а также подстановка одного в другой в качестве аргумента всё ещё оставляют результат полиномом</li>
							<li>Это свойство удобно при комбинировании алгоритмов</li>
						</ul>
					</section>
					<section>
						<h4>Почему именно полином</h4>
						<ul>
							<li>Наконец, смена модели вычислителя всегда оставляет полиномиальный алгоритм полиномиальным (если не учитывать квантовые вычисления)</li>
							<li>Т.е. задача, решаемая за полиномиальное время на обычном ПК (более формально — машине с произвольным доступом к памяти), может быть за полиномиальное время решена и на машине Тьюринга</li>
						</ul>
					</section>
					<section>
						<h4>Класс сложности $NP$</h4>
						<ul>
							<li>Класс сложности $NP$ содержит задачи, правильность предоставленного решения которых можно проверить за полиномиальное время</li>
							<li>Т.е. если кто-то уже решил конкретный экземпляр задачи (неважно, сколько времени было на это потрачено), проверить, правильное ли получилось решение, можно за полиномиальное время</li>
						</ul>
					</section>
					<section>
						<h4>Пример задачи из $NP$</h4>
						<ul>
							<li>К примеру, существует задача поиска гамильтонова цикла в графе</li>
							<li>Пусть дан граф $G = (V, E)$, нужно определить, есть ли в графе путь, проходящий все вершины ровно по $1$ разу и возвращающийся в исходную вершину</li>
						</ul>
					</section>
					<section>
						<h4>Поиск гамильтонова цикла</h4>
						<ul>
							<li>Решить задачу поиска гамильтонова цикла за полиномиальное время на данный момент не представляется возможным</li>
							<li>Однако, если кто-то предоставит решение для конкретного графа в виде последовательности вершин, составляющих гамильтонов цикл, легко проверить, является ли эта последовательность решением</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Отношение между $P$ и $NP$</h4>
						<ul>
							<li>Очевидно, что все задачи из $P$ также входят в $NP$ (т.е. $P \subseteq NP$)</li>
							<li>Это справедливо, т.к., если решешние задачи можно получить за полиномиальное время, то, чтобы проверить правильность предоставленного решения, можно просто решить задачу заново и сравнить результат</li>
						</ul>
					</section>
					<section>
						<h4>Отношение между $P$ и $NP$</h4>
						<ul>
							<li>Однако остаётся открытым вопрос о $P \stackrel{?}{=} NP$</li>
							<li>Несмотря на то, что, чтобы отнести задачу к классу $P$, необходимо только предоставить алгоритм её решения, работающий за полиномиальное время, если такой алгоритм <b>пока что</b> не найден, это не является доказательством того, что задача не входит в $P$</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>$NP$-полные задачи</h4>
						<ul>
							<li>Весомым (но не достаточным для доказательства) аргументом в пользу того, что $P \neq NP$, является существование $NP$-полных задач</li>
							<li>$NP$-полная задача — задача из $NP$, к которой могут быть за полиномиальное время <b>сведены</b> все остальные задачи из $NP$</li>
						</ul>
					</section>
					<section>
						<h4>Сведение</h4>
						<ul>
							<li>Сведением называется процесс представления экземпляров одной задачи в качестве экземпляров другой</li>
							<li>Алгоритм сведения должен преобразовывать входы $I_1$ первой задачи $Q_1$ во входы $I_2$ второй задачи $Q_2$ таким образом, чтобы решение $Q_1$ со входом $I_1$ совпадало с решением $Q_2$ со входом $I_2$</li>
						</ul>
					</section>
					<section>
						<h4>Пример сведения</h4>
						<ul>
							<li>К примеру, задачу решения линейного уравнения $a_1x + b_1 = 0$ можно свести к задаче решения квадратного уравнения $a_2x^2 + b_2x + c_2 = 0$</li>
							<li>Сделать это можно, положив $a_2 = 0, b_2 = a_1, c_2 = b_1$</li>
							<li>После такого сведения решения квадратного уравнения будут совпадать с решениями линейного</li>
						</ul>
					</section>
					<section>
						<h4>Следствие сводимости</h4>
						<ul>
							<li>Пусть задачу $Q_1$ можно свести к задаче $Q_2$ так, что алгоритм сведения будет работать не сложнее, чем решения самих задач</li>
							<li>Из этого следует, что задача $Q_2$ решается <b>не проще</b>, чем задача $Q_1$</li>
							<li>Тогда, если достоверно известно, что $Q_1$ нельзя решить быстрее, чем за некоторое $T(N)$, то и $Q_2$ нельзя решить быстрее, чем за $T(N)$</li>
						</ul>
					</section>
					<section>
						<h4>$NP$-полные задачи</h4>
						<ul>
							<li>Таким образом, любую $NP$-полную задачу решить не проще, чем все остальные $NP$-полные задачи, т.к. все они сводятся друг к другу за полиномиальное время</li>
							<li>Более того, если хотя бы для одной $NP$-полной задачи найдётся решение за полиномиальное время, это сразу же даст решение <b>всех</b> остальных $NP$-полных задач за полиномиальное время</li>
						</ul>
					</section>
					<section>
						<h4>Следствие</h4>
						<ul>
							<li>Таким образом, чтобы доказать, что для задачи не существует эффективного алгоритма решения, достаточно показать, что к ней сводится хотя бы одна $NP$-полная задача</li>
							<li>Такое сведение будет гарантией отсутствия полиномиального решения этой задачи по крайней мере до тех пор, пока не будет доказано, что $P = NP$</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>$NP$-сложные задачи</h4>
						<ul>
							<li>Следует также отличать отдельный класс $NP$-сложных задач</li>
							<li>В этот класс входят задачи, лежащие за рамками $NP$</li>
							<li>Для таких задач и поиск решения и его верификация работают сложнее, чем за полиномиальное время</li>
						</ul>
					</section>
					<section>
						<h4>Примеры $NP$-полных задач</h4>
						<ul>
							<li>Примечательно, что задачи из класса $P$ и $NP$-полные задачи зачастую имеют мало отличий</li>
							<li>Задача поиска кратчайшего пути между вершинами на графе принадлежит к классу $P$, тогда как задача поиска саомго длинного пути — $NP$-полная</li>
						</ul>
					</section>
					<section>
						<h4>Примеры $NP$-полных задач</h4>
						<ul>
							<li>Задача поиска эйлерова цикла на графе решается за полиномиальное время, а задача поиска гамильтонова цикла — $NP$-полная</li>
							<li>Задача проверки выполнимости $2-CNF$ решается за полиномиальное время, а задача проверки выполнимости $3-CNF$ — $NP$-полная</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Полезные источники</h4>
						<ol>
							<li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 34.</li>
							<li><b>RU</b> С. Скиена. Алгоиртмы. Руководство по разработке. 2-е издание. Глава 9 – Более простое и краткое объяснение.</li>
							<li><b>RU</b> А.Левитин. Алгоритмы: введение в разработку и анализ. Глава 10 — ещё один вариант изложения материала</li>
						</ol>
					</section>
					<section>
						<h4>Полезные источники</h4>
						<ol start="4">
							<li><b>RU</b> <a href='https://youtube.com/playlist?list=PL4_hYwCyhAvYJ1r22vWqp_sDwJMNf64MN&feature=shared'>Курс видеолекций</a> от преподавателя из МФТИ</li>
						</ol>
					</section>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>