<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Алгоритмизация и Программирование</h3>
					<div>&nbsp;</div>
					<h4>Морозов Владимир Игоревич</h4>
				</section>
				<section>
					<h4>$B$-деревья</h4>
				</section>
				<section>
					<section>
						<h4>Постановка проблемы</h4>
						<ul>
							<li>Древовидные структуры позволяют достаточно эффективно манипулировать хранимыми с них данными</li>
							<li>Это делает их пригодными для хранения больших объёмов информации, например, для реализации баз данных (БД)</li>
						</ul>
					</section>
					<section>
						<h4>Постановка проблемы</h4>
						<ul>
							<li>Т.к. объём информации, хранимый в БД зачастую превышает размеры оперативной памяти, большую часть древовидной структуры приходится хранить на диске (в энергонезависимом запоминающем устройстве)</li>
							<li>Операции ввода-вывода с диском происходят на порядки медленнее, чем такие же операции с оперативной памятью, а значит, для обеспечения эффективности требуется минимизировать их количество</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Определение $B$-дерева</h4>
						<ul>
							<li>Решить поставленную проблему помогают специальные структуры данных под названием $B$-деревья</li>
							<li>Это недвоичные деревья поиска, обладающие свойствами, представленными на следующих слайдах</li>
						</ul>
					</section>
					<section>
						<h4>Определение $B$-дерева</h4>
						<ol>
							<li>
								Каждый узел дерева содержит:
								<ul>
									<li>Число $n$ ключей, хранящийся в узле в данный момент</li>
									<li>Сами ключи ($n$ штук), расположенные в порядке возрастания</li>
									<li>Логическое значение $leaf$, показывающее, является ли узел листом</li>
									<li>$n+1$ указателей на дочерние узлы (возможно, $NULL$)</li>
								</ul>
							</li>
						</ol>
					</section>
					<section>
						<h4>Определение $B$-дерева</h4>
						<ol start="2">
							<li>
								Указатели на дочерние узлы содержатся между ключами данного узла, при этом:
								<ul>
									<li>Пусть есть узел $x$, в котором между ключами $k^x_j$ и $k^x_{j + 1}$ стоит указатель на дочерний узел $y$</li>
									<li>Тогда для всех ключей $k^y_i$ узла $y$ выполнаяется: $k^x_j \leqslant k^y_i \leqslant k^x_{j + 1}$</li>
									<li>То есть ключи $k^x_j$ узла $x$ делят множество ключей всех дочерних узлов на поддиапазоны от $k^x_j$ до $k^x_{j + 1}$</li>
								</ul>
							</li>
						</ol>
					</section>
					<section>
						<h4>Определение $B$-дерева</h4>
						<ol start="3">
							<li>Все листья дерева расположены на одной глубине, равной высоте дерева $h$</li>
					</section>
					<section>
						<h4>Определение $B$-дерева</h4>
						<ol start="4">													
							<li>
								Существует параметр $t \geqslant 2$, называемый <b>минимальной степенью</b> $B$-дерева:
								<ul>
									<li>Каждый узел, кроме корневого, должен содержать минимум $t - 1$ ключей и, соответственно, минимум $t$ дочерних узлов</li>
									<li>Каждый узел должен содержать не более $2t - 1$ ключей и, соответственно, не более $2t$ дочерних узлов</li>
									<li>Если узел содержит $2t - 1$ ключей, он считается <b>заполненным</b></li>
								</ul>
							</li>
						</ol>
					</section>
					<section>
						<h4>Пример $B$-дерева</h4>
						<p>
							<img src="06/example.png">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Свойство $B$-дерева</h4>
						<ul>
							<li>Количество обращений к диску, необходимое для выполнения операций с $B$-деревом, пропорционально его высоте $h$</li>
							<li>Высота $B$-дерева в худшем случае:</li>
							$$h = log_t\frac{N + 1}{2} = O(log_tN)$$
						</ul>
					</section>
					<section>
						<h4>Преимущество $B$-дерева</h4>
						<ul>
							<li>Большие объёмы данных чаще всего хранятся на жёстких дисках</li>
							<li>Физически такие диски представлены в виде совокупности вращающихся дисковых пластин, расположенных друг над другом и разделённых на дорожки</li>
							<li>Каждая дорожка жёсткого диска разбивается на фрагменты, называемые секторами</li>
						</ul>
					</section>
					<section>
						<h4>Преимущество $B$-дерева</h4>
						<ul>
							<li>Сектор – наименьшая адресуемая единица обмена данными дискового устройства с оперативной памятью [3]</li>
							<li>Т.е. наиболее быстрая операция для диска – считывание одного сектора</li>
							<li>Таким образом, если установить $t$ так, чтобы размер узла был равен размеру сектора, можно максимально оптимизировать работу с диском, считывая по одному узлу дерева за одну дисковую операцию</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Операции на $B$-дереве</h4>
						<p align="left">$B$-дерево предоставляет стандартные операции для древовидной структуры:</p>
						<ul>
							<li>Поиск элемента по ключу</li>
							<li>Вставка элемента с новым ключом</li>
							<li>Удаление элемента с заданным ключом</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Поиск элемента в $B$-дереве</h4>
						<ul>
							<li>Чтобы найти узел в $B$-дереве необходимо, начиная с корня, рекурсивно спускаться по узлам, в каждом из узлов переходя по указателю стоящему перед наименьшим ключом, большим, чем искомый</li>
							<li>Операция включает $O(h)$ чтений с диска, т.к. включает один проход по простому нисходящему пути</li>
						</ul>
					</section>
					<section>
						<h4>Поиск элемента $20$</h4>
						<p>
							<img src="06/search_20.png">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Разбиение узла</h4>
						<ul>
							<li>Операция вставки нового ключа в $B$-дерево осуществляется сложнее, чем аналогичная операция для двоичного дерева поиска</li>
							<li>Сложность объясняется тем, что необходимо сохранять свойства $B$-дерева, а именно ограничения на количество ключей в каждой вершине</li>
						</ul>
					</section>
					<section>
						<h4>Разбиение узла</h4>
						<ul>
							<li>Чтобы уменьшить количество узлов в вершине в случае, когда она является заполненной и в неё должна быть произведена вставка, вводится вспомогательная операция – <b>разбиение заполненного узла</b></li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм разбиения</h4>
						<ul>
							<li>Для разбиения в узле выделяется средний ключ – <b>медиана</b> $m$</li>
							<li>Далее медиана поднимается в родительский узел (если текущий узел – корень, родительский создаётся и становится корнем)</li>
							<li>Оставшиеся две части разбиваемого узла становятся двумя новыми узлами</li>
							<li><b>Разбиение – единственный способ увеличения высоты $B$-дерева</b></li>
						</ul>
					</section>
					<section>
						<h4>Разбиение узла</h4>
						<p>
							<img src="06/split.png">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Разбиения при вставке в $B$-дерево</h4>
						<ul>
							<li>Очевидно, разбиение применяется тогда, когда узел, в который необходимо вставить ключ, заполнен</li>
							<li>Однако может возникнуть проблема – родительский для данного узел, в который поднимается медиана, тоже может быть заполнен</li>
							<li>Тогда разбиение потребует рекурсивного прохода вверх в худшем случае до самого корня</li>
						</ul>
					</section>
					<section>
						<h4>Разбиения при вставке в $B$-дерево</h4>
						<ul>
							<li>Чтобы этого не происходило, когда при вставке узла происходит спуск по простому нисходящему пути для поиска места вставки, все встреченные на пути <b>заполненные узлы сразу разбиваются</b></li>
							<li>Это позволяет произвести вставку за один проход по простому нисходящему пути</li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм вставки в $B$-дерево</h4>
						<ol>
							<li>Спускаться по простому нисходящему пути, выбирая те дочерние узлы, в диапазоне которых находится вставляемый ключ</li>
							<li>Если узел, встретившийся на таком пути, заполнен, его необходимо разбить и перейти в один из двух получившихся узлов по правилу из п. $1$</li>							
							<li>Когда на пути встретится лист дерева, следует найти в нём место для вставляемого ключа и вставить его</li>
						</ol>
					</section>
					<section>
						<h4>Вставка элемента $18.5$</h4>
						<p>
							<img src="06/insert_18_5.png">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Удаление элемента из $B$-дерева</h4>
						<ul>
							<li>Удаление элемента из $B$-дерева, очевидно, уменьшает размер узла, из которого оно производится, на $1$</li>
							<li>В таком случае, если размер узла до удаления был равен $t - 1$, нарушится свойство<br>$B$-дерева</li>							
							<li>А значит, необходимо, чтобы во всех узлах, по которым будет осуществляться проход для поиска удаляемого элемента, было, как минимум, $t$ ключей</li>
						</ul>
					</section>
					<section>
						<h4>Удаление элемента из $B$-дерева</h4>
						<ol>
							<li>Заимствование ключа у соседнего узла</li>
							<li>Слияние узла с соседним</li>
							<li>А значит, необходимо, чтобы во всех узлах, по которым будет осуществляться проход для поиска удаляемого элемента, было, как минимум, $t$ ключей</li>
						</ol>
					</section>
					<section>
						<h4>Заимствование ключа</h4>
						<ul>
							<li>Чтобы увеличить количество ключей в данном узле, можно забрать один ключ у одного из его &laquo;соседей&raquo; – узлов, указатели на который в родительском стоят справа и слева от указателя на данный</li>
							<li>Это сработает, если существует хотя бы один сосед, в котором есть хотя бы $t$ узлов</li>
						</ul>
					</section>
					<section>
						<h4>Заимствование ключа</h4>
						<p>
							<img src="06/taking_key.png">
						</p>
					</section>
					<section>
						<h4>Слияние соседних узлов</h4>
						<p align="left">Если у узла не нашлось соседей, в которых есть хотя бы $t$ ключей, его можно слить с одним из этих соседей. Операция слияния обратна операции разбиения.</p>
						<p>
							<img src="06/merge.png">
						</p>
					</section>
					<section>
						<h4>Удаление элемента из $B$-дерева</h4>
						<ul>
							<li>Теперь, когда обеспечено наличие в каждом узле хотя бы $t$ ключей, можно приступать непосредственно к удалению</li>
							<li>Необходимо рассмотреть несколько ситуаций</li>							
							<li>Самая простая (и часто встречающаяся) из ситуаций – когда удаляемый элемент находится в листе дерева</li>
							<li>Тогда можно просто удалить ключ из узла, сохранив свойства $B$-дерева, т.к. до этого мы убедились, что в узле хотя бы $t$ ключей</li>
						</ul>
					</section>
					<section>
						<h4>Удаление элемента из $B$-дерева</h4>
						<p align="left">
							Остальные ситуации описывают случаи, когда удаляемый элемент находится в нелистовом узле. В таком случае:
						</p>
						<ul>
							<li>Если левый или правый потомок удаляемого ключа имеют хотя бы $t$ ключей, спустимся рекурсивно по поддереву с корнем в этом потомке в поиске максимального (для левого) или минимального (для правого) элемента, поддерживая при этом хотя бы $t$ ключей в каждом узле, как было описано ранее</li>
						</ul>
					</section>
					<section>
						<h4>Удаление элемента из $B$-дерева</h4>
						<ul>
							<li>Найденный элемент переместим на место удаляемого</li>
							<li>На следующем слайде продемонстрирована ситуация, описанная на предыдущем слайде</li>
							<li>Удаляется элемент $15$</li>
						</ul>
					</section>
					<section>
						<h4>Удаление элемента из $B$-дерева</h4>
						<p>
							<img src="06/delete_15.png">
						</p>
					</section>
					<section>
						<h4>Удаление элемента из $B$-дерева</h4>
						<p align="left">В случае, когда ни один из потомков удаляемого ключа не имеет хотя бы $t$ ключей, необходимо слить его потомков, как это делалось для поддержания $t$ ключей при рекурсивном проходе вниз, и рекурсивно повторить удаление из получившегося узла</p>
					</section>
					<section>
						<h4>Удаление элемента $31$</h4>
						<p>
							<img src="06/delete_31.png">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Сложность операций на $B$-дереве</h4>
						<table>
							<tr>
								<th>Операция</th> <th>Сложность по процессорному времени</th> <th>Сложность по обращениям к диску</th>
							</tr>
							<tr>
								<td>Поиск</td> <td>$O(th)$</td> <td>$O(h)$</td>
							</tr>
							<tr>
								<td>Вставка</td> <td>$O(th)$</td> <td>$O(h)$</td>
							</tr>
							<tr>
								<td>Удаление</td> <td>$O(th)$</td> <td>$O(h)$</td>
							</tr>
						</table>
					</section>
				</section>
				<section>
					<section>
						<h4>Полезные источники</h4>
						<ol>
							<li><b>RU</b> <a href='https://youtu.be/chYJ0IzL5Og'>Лекция</a> преподавателя из МФТИ (более простое объяснение удаления)</li>
							<li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 18 – Основная книга нашего курса.</li>							
							<li><b>RU</b> В.Г. Олифер, Н.А. Олифер. Сетевые операционные системы. 2-е издание (2009). Глава 7, раздел “Физическая организация файловой системы” – Подробное описание организации хранения файлов на диске</li>
						</ol>
					</section>
					<section>
						<h4>Полезные источники</h4>
						<ol start="4">
							<li><b>RU</b> <a href='https://rus-linux.net/lib.php?name=/MyLDP/hard/memory/memory.html'>Набор статей</a> про память компьтера</li>
							<li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/BTree.html'>Визуализация</a> $B$-дерева</li>
						</ol>
					</section>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>