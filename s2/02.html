<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3>Алгоритмизация и Программирование</h3>
                    <div>&nbsp;</div>
                    <h4>Морозов Владимир Игоревич</h4>
                </section>
                <section>
                    <h4>Хеш-таблицы</h4>
                </section>
                <section>
                    <section>
                        <h4>Постановка проблемы</h4>
                        <ul>
                            <li>Массивы – достаточно быстрые контейнеры</li>
                            <li>При условии, что заранее выделено необходимое количество памяти, вставка элементов в пустые ячейки, а также поиск и удаление (без сдвига последующих) происходит за $O(1)$</li>
                            <li>Наряду с обычными массивами существуют ассоциативные массивы, в которых ключами являются не числа-индексы, а произвольные данные (например, <code data-trim class="python">dict</code> в Python)</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Постановка проблемы</h4>
                        <ul>
                            <li>Чтобы достичь сравнимой производительности, необходимо средство, преобразующее произвольные ключи в числа</li>
                        </ul>                        
                    </section>
                    <section>
                        <h4>Визуализация</h4>
                        <p>
                            <img src="02/Assoc_arr.png" height="60%" width="60%">
                        </p>
                    </section>
                    <section>
                        <h4>Хеш-функция</h4>
                        <ul>
                            <li><b>Хеш-функция</b> — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины.</li>
                            <li>В нашем случае, т.к. битовая строка установленной длины может быть всегда представлена в виде числа, будем рассматривать хеш-функцию как некоторую функцию, отображающую всё множество ключей в некоторое число.</li>
                        </ul>                        
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Хеш-таблица</h4>
                        <ul>
                            <li>Представим массив $T$ с количеством ячеек, равным $m$. Тогда хеш-функция может быть определена так:</li>
                            $$h: U \rightarrow \{0,...,m-1\},$$
                            <li>где $U = \{k_1,k_2,k_3,...\}$ – некоторое (возможно, бесконечное) множество различных ключей, которые могут использоваться для доступа к элементам. Как правило, выполняется: $|U| &gt;&gt; m$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Хеш-таблица</h4>
                        <p align="left">
                            Таким образом, мы можем эффективно оперировать элементами с произвольными ключами в массиве $T$, получая индекс каждого очередного элемента из его ключа $k$ с помощью $h(k)$.
                        </p>
                        <p>
                            <img src="02/hash_table.png" height="60%" width="60%">
                        </p>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Коллизии</h4>
                        <ul>
                            <li>Тот факт, что $|U| &gt;&gt; m$ делает возможной ситуацию, когда найдётся такая пара ключей $k1 \neq k2$, для которых будет выполняться $h(k_1) = h(k_2)$</li>
                            <li>А значит, два элемента с двумя <b>разными</b> ключами будут отображены на </b>одну и ту же</b> ячейку массива $T$</li>
                            <li>Такая ситуация называется <b>коллизией</b></li>
                        </ul>
                    </section>
                    <section>
                        <h4>Визуализация коллизии</h4>
                        <p>
                            <img src="02/collision.png">
                        </p>
                    </section>
                    <section>
                        <h4>Разрешение коллизий</h4>
                        <p align="left">
                            Чтобы разрешить возникшую коллизию, т.е. каким-то образом сохранить элементы, хеши которых равны, причём так, чтобы их можно было различать при поиске, существуют два подхода:
                        </p>
                        <ol>
                            <li>Метод цепочек</li>
                            <li>Метод открытой адресации</li>
                        </ol>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Метод цепочек</h4>
                        <ul>
                            <li>Массив $T$ изначально заполняется некоторыми значениями $NULL$, обозначающими отсутствие элемента</li>
                            <li>Далее, при вставке значения на позицию в массив помещается головной элемент связного списка, в котором содержится это значение</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Метод цепочек</h4>
                        <ul>
                            <li>При обнаружении коллизии новый элемент помещается в тот же связный список (сложность $O(1)$)</li>
                            <li>Когда необходимо найти элемент по ключу $k$, сначала за $O(1)$ производится поиск нужного связного списка в массиве по индексу $h(k)$</li>
                            <li>После этого в связном списке производится поиск элемента по значению ключа за $O(l)$, где $l$ – длина соответствующего списка</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Визуализация метода цепочек</h4>
                        <p>
                            <img src="02/ll_method.png" height="75%" width="75%">
                        </p>
                    </section>
                    <section>
                        <h4>Анализ производительности</h4>
                        <ul>
                            <li>Т.к. поиск нужного списка по ключу происходит за $O(1)$, основу вычислительной сложности составляет поиск элемента в самом списке</li>
                            <li>
                                Для анализа введём величину $\alpha = \frac{m}{n}$, где:
                                <ul>
                                    <li>$m$ – количество ячеек в массиве</li>
                                    <li>$n$ – общее количество элементов, сохранённых в таблице</li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ производительности</h4>
                        <ul>
                            <li>Тогда в среднем поиск элемента будет производиться за $\Theta(\alpha)$</li>
                            <li>Тогда, если поддерживать $\alpha$ постоянным, поиск будет производиться за $O(1)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ производительности</h4>
                        <ul>
                            <li>Чтобы поддерживать $\alpha$ постоянным, нужно при вставке (увеличении $n$) увеличивать величину $m$ раз в $m$ вставок</li>
                            <li>Если увеличивать его вдвое, амортизированная сложность вставки станет тоже $O(1)$ по аналогии с динамическим массивом</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Метод открытой адресации</h4>
                        <ul>
                            <li>В методе открытой адресации все элементы хранятся непосредственно в массиве $T$</li>
                            <li>Каждая ячейка массива $T$ содержит либо хранимый элемент, либо значение $NULL$, либо значение $DELETED$</li>
                            <li>При вставке элемента все ячейки массива просматриваются, начиная с ячейки $h(k)$ по определённому правилу, пока не будет найдена пустая ячейка со значением $NULL$, в которую и будет произведена вставка</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Метод открытой адресации</h4>
                        <ul>
                            <li>При поиске элемента все ячейки массива просматриваются, начиная с ячейки $h(k)$ по определённому правилу, пока не будет найдена ячейка с нужным ключом (элемент найден) или не встретится ячейка $NULL$ (элемент не найден)</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Правила поиска</h4>
                        <ul>
                            <li>Введём $h(k, i)$, возвращающую номер ячейки, которую нужно просмотреть на $i$-ой итерации поиска</li>
                            <li>При этом $i = \{0, ..., m - 1\}$</li>
                            <li>Тогда нашу обычную хеш-функцию назовём $h'(k)$</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Правила поиска</h4>
                        <p align="left">
                            Существуют следующие правила поиска:
                        </p>
                        <ul>
                            <li>Линейное исследование:<br>$h(k, i) = (h'(k) + i) mod\ m$</li>
                            <li>Квадратичное исследование:<br>$h(k, i) = (h'(k) + c_1i + c_2i^2) mod\ m$, где $c_1$ и $c_2$ – некоторые целые положительные константы</li>
                            <li>Двойное хеширование:<br>$h(k, i) = (h_1(k) + ih_2(k)) mod\ m$, где $h_1$ и $h_2$ – две разные простые хеш-функции</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Анализ производительности</h4>
                        <ul>
                            <li>Доказано [1], что вставка при открытой адресации занимает время $O(\frac{1}{1-\alpha})$</li>
                            <li>Поиск занимает: $O(\frac{1}{\alpha}ln(\frac{1}{1-\alpha}))$</li>
                            <li>Также не стоит забывать о том, что при открытой адресации может возникнуть ситуация, когда таблица будет заполнена, т.к. все элементы хранятся непосредственно в ней</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Хеш-функции</h4>
                        <ul>
                            <li>Существует большое количество различных хеш-функций, удовлетворяющих различным требованиям</li>
                            <li>В нашем случае важно требование <b>простого равномерно хеширования</b>, гласящее, что для каждого ключа <b>равновероятно</b> помещение в одну из $m$ ячеек вне зависимости от хеширования остальных ключей</li>
                            <li>Это позволяет заполнять хеш-таблицу равномерно, не "вытягивая" длинные цепочки, в случае, если входные данные случайны</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Простые хеш-функций</h4>
                        <ul>
                            <li>Чтобы строить простые хеш-функции, удобнее работать только с целыми неотрицательными числами в качестве входных значений</li>
                            <li>А значит, необходима некоторая функция int, преобразующая любые входные данные к такому числу:</li>
                            $$int: U \rightarrow \N$$
                        </ul>
                    </section>
                    <section>
                        <h4>Простые хеш-функций</h4>
                        <ul>
                            <li>Самый простой способ реализовать такую функцию – взять двоичное представление данных и представить его, как число</li>
                            <li>Для различных типов данных существуют различные функции</li>
                        </ul>
                    </section>
                    <section>
                        <h4>Примеры простых хеш-функций</h4>
                        <ul>
                            <li>Метод деления:<br>$h(k) = int(k) mod\ m$</li>
                            <li>
                                Метод умножения:<br>$h(k) = \lfloor m(int(k)A\ mod\ 1)\rfloor$, где:
                                <ul>
                                    <li>$0 &lt; A &lt; 1$,</li> 
                                    <li>$mod\ 1$ – получение дробной части вещественного числа</li>
                                    <li>$\lfloor\rfloor$ – округление в меньшую сторону</li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h4>Примеры простых хеш-функций</h4>
                        <p align="left">Обе представленные функции не решают одну проблему: злоумышленник может намеренно подбирать значения ключей таким образом, чтобы они отображались в один и тот же хеш, вызывая тем самым “выстраивание” всех значений в одну цепочку и сводя сложность поиска к $O(n)$</p>
                    </section>
                    <section>
                        <h4>Универсальное хеширование</h4>
                        <ul>
                            <li>Чтобы избежать проблемы, описанной на предыдущем слайде, используется <b>универсальное хеширование</b></li>
                            <li>При создании контейнера хеш функция выбирается случайным образом из некоторого заранее определённого набора схожих хеш-функций</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Реализация в C++</h4>
                        <ul>
                            <li>
                                На основе хеш-таблиц в C++ реализованы следующие контейнеры:
                                <ul>
                                    <li><code data-trim class="cpp">std::unordered_set</code></li>
                                    <li><code data-trim class="cpp">std::unordered_map</code></li>
                                </ul>
                            </li>
                            <li>В обоих контейнерах используется метод цепочек</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol>
                            <li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 11 – Основная книга нашего курса.</li>
                            <li><b>RU</b> С. Скиена. Алгоиртмы. Руководство по разработке. 2-е издание. Подраздел 3.7 – Более простое и краткое объяснение.</li>
                            <li><b>RU</b> <a href='https://habr.com/ru/articles/178955/'>Статья</a> про атаки на хеш-функции</li>
                        </ol>
                    </section>
                    <section>
                        <h4>Полезные источники</h4>
                        <ol start="4">
                            <li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/OpenHash.html?authuser=0'>Визуализация</a> хеш-таблиц</li>
                            <li><b>EN</b> <a href='https://visualgo.net/en/hashtable'>Более красивая визуализация</a> хеш-таблиц</li>
                        </ol>
                    </section>
                </section>
            </div>
        </div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>