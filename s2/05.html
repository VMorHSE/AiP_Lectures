<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Алгоритмизация и Программирование</h3>
					<div>&nbsp;</div>
					<h4>Морозов Владимир Игоревич</h4>
				</section>
				<section>
					<h4>Красно-чёрные деревья</h4>
				</section>
				<section>
					<section>
						<h4>Постановка проблемы</h4>
						<ul>
							<li>Рассмотренные ранее двоичные деревья поиска предоставляли хорошую эффективность ($O(log_2(N))$), если были сбалансированы</li>
							<li>Однако возможна и ситуация, представленная на следующем слайде</li>
							<li>Чтобы поддерживать сбалансированное состояние, используются деревья со специальной структурой, одно из которых мы и рассмотрим</li>
						</ul>
					</section>
					<section>
						<h4>Проблема BST</h4>
						<p>
                            <img src="05/problem.png" width="80%" height="80%">
                        </p>
					</section>
				</section>
				<section>
					<section>
						<h4>Постановка проблемы</h4>
						<ul>
							<li>Для преобразования дерева без нарушения свойства двоичного дерева поиска используются повороты – алгоритмы перестановки связей между несколькими вершинами в дереве</li>
							<li>Существуют два поворота: налево и направо</li>
						</ul>
					</section>
					<section>
						<h4>Повороты</h4>
						<p>
                            <img src="05/rotations.png">
                        </p>
					</section>
					<section>
						<h4>Поворот направо</h4>
						<ul>
							<li>Поворот производится относительно одной вершины</li>
							<li>Для совершения правого поворота у вершины должен существовать левый потомок</li>
							<li>Если это условие выполняется, поворот осуществляется по следующему алгоритму</li>
						</ul>
					</section>
					<section>
						<h4>Поворот направо</h4>
						<ol>
							<li>Бывший левый потомок $y$ текущего узла $x$ становится его родителем</li>
							<li>Текущий узел $y$ становится правым потомком своего бывшего левого потомка $x$</li>
							<li>Бывший правый потомок левого потомка $\beta$ текущего узла становится левым потомком текущего узла $y$</li>
							<li>Остальные связи остаются неизменны</li>
						</ol>
					</section>
					<section>
						<h4>Поворот налево</h4>
						<ul>
							<li>Левый поворот выполняется симметрично правому</li>
							<li>Т.е., чтобы получить алгоритм для левого поворота нужно в алгоритме для правого поменять местами все слова &laquo;левый&raquo; и &laquo;правый&raquo;</li>
							<li>Т.к. поворот включает фиксированное количество перестановок связей, его сложность $O(1)$</li>
						</ul>
					</section>
					<section>
						<h4>Поворот налево</h4>
						<p>
                            <img src="05/big_rotation.png" width="80%" height="80%">
                        </p>
					</section>
				</section>
				<section>
					<section>
						<h4>Красно-чёрное дерево</h4>
						<p align="left">
							Красно-чёрное дерево – двоичное дерево поиска, в котором выполняются пять свойств:
						</p>
						<ol>
							<li>Каждый узел имеет цвет: красный или чёрный</li>
							<li>Корень дерева (но не поддерева) – всегда чёрный узел</li>
							<li>Листьями дерева являются специальные элементы $NULL$ и они тоже чёрные</li>
						</ol>
					</section>
					<section>
						<h4>Красно-чёрное дерево</h4>
						<ol start="4">
							<li>Если узел красный, то оба его дочерних узла чёрные</li>
							<li>Для каждого узла все простые пути от него до листьев, являющихся потомками данного узла, содержат одно и то же количество чёрных узлов</li>
						</ol>
					</section>
					<section>
						<h4>Пример</h4>
						<p>
                            <img src="05/example.png">
                        </p>
					</section>
					<section>
						<h4>Преимущества</h4>
						<ul>
							<li>Организация дерева представленным образом даёт одно важнейшее свойство</li>
							<li>Для каждого поддерева выполняется, что его высота может превышать высоту соседнего поддерева не более чем вдвое</li>
							<li>За счёт этого в дереве всегда поддерживается состояние, близкое к сбалансированному, что позволяет всем операциям гарантированно выполняться за $O(log_2(N))$</li>
						</ul>
					</section>
					<section>
						<h4>Эффективное представление нулевых вершин</h4>
						<ul>
							<li>Т.к. нулевая вершина должна иметь цвет, мы не можем заменить её просто указателем на $NULL$</li>
							<li>Однако, т.к. эти вершины всегда чёрные, никогда не имеют значений и никогда не указывают на потомков, мы можем заменить их все единственной нулевой вершиной</li>
						</ul>
					</section>
					<section>
						<h4>Эффективное представление нулевых вершин</h4>
						<p>
                            <img src="05/optimization.png" height="90%" width="90%">
                        </p>
					</section>
				</section>
				<section>
					<section>
						<h4>Алгоритмы на красно-чёрном дереве</h4>
						<p align="left">
							Т.к. красно-чёрное дерево представляет собой двоичное дерево поиска, все алгоритмы поиска на нём остаются неизменны, а именно:
						</p>
						<ul>
							<li>Поиск элемента по ключу</li>
							<li>Поиск наибольшего и наименьшего элементов</li>
							<li>Поиск элемента, следующего за данным и предыдущего для данного</li>
						</ul>
						<p align="left">
							Однако вставка и удаление элементов могут нарушить свойство красно-чёрного дерева, поэтому для них разработаны новые алгоритмы
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Вставка (insert)</h4>
						<ul>
							<li>Первый этап вставки происходит так же, как и в обычном двоичном дереве поиска</li>
							<li>Однако при этом вставляемый узел обязательно окрашивается в красный цвет</li>
						</ul>
					</section>
					<section>
						<h4>Вставка элемента $26$</h4>
						<p>
                            <img src="05/lucky_insert.png">
                        </p>
					</section>
					<section>
						<h4>Нарушение свойств при вставке</h4>
						<p align="left">
							При вставке все свойства дерева могут сразу выполниться (как на предыдущем слайде), но также два из них могут быть нарушены:
						</p>
						<ul>
							<li>В случае, если дерево изначально было пустым, при вставке красного узла корень окажется красным</li>
							<li>Это нарушение свойства $2$</li>
							<li>Чтобы исправить это, просто перекрасим корень в чёрный</li>
						</ul>
					</section>
					<section>
						<h4>Нарушение свойств при вставке</h4>
						<ul>
							<li>В случае, если узел, родительский для вставленного, красный, нарушается свойство $4$</li>
							<li>Исправление этого нарушения будет рассмотрено далее</li>
						</ul>
					</section>
					<section>
						<h4>Ситуация $2$</h4>
						<p>
                            <img src="05/insert_sit_2.png">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2$</h4>
						<p align="left">
							В таком случае возможны две подситуации:
						</p>
						<ul>
							<li>&laquo;Дядя&raquo; (второй потомок родителя родителя) вставляемого узла красный ($2.1$)</li>
							<li>&laquo;Дядя&raquo; вставляемого узла чёрный ($2.2$)</li>
						</ul>
					</section>
					<section>
						<h4>Подситуации $2.1$ и $2.2$</h4>
						<p>
                            <img src="05/21_22.png">
                        </p>
					</section>
					<section>
						<h4>Подситуация $2.1$</h4>
						<p align="left">В данном случае для восстановления всех свойств нужно перекрасить родителя родителя в красный, а родителя и &laquo;дядю&raquo; – в чёрный:</p>
						<p>
                            <img src="05/21.png">
                        </p>
					</section>
					<section>
						<h4>Подситуация $2.2$</h4>
						<p align="left">В случае $2.2$ может быть ещё два подслучая:</p>
						<ol>
							<li>Вставляемый узел – левый потомок для своего родителя ($2.2.1$)</li>
							<li>Вставляемый узел – правый потомок для своего родителя ($2.2.2$)</li>
						</ol>
					</section>
					<section>
						<h4>Случаи $2.2.1$ и $2.2.2$</h4>
						<p>
                            <img src="05/221_222.png">
                        </p>
					</section>
					<section>
						<h4>Случай $2.2.1$</h4>
						<p align="left">В случае $2.2.1$ необходимо сделать поворот направо относительно родителя родителя и перекрасить цвета:</p>
						<p>
                            <img src="05/221.png">
                        </p>
					</section>
					<section>
						<h4>Случай $2.2.1$</h4>
						<p align="left">В случае $2.2.2$ необходимо сделать поворот налево относительно родителя вставляемого узла и мы получим случай $2.2.1$:</p>
						<p>
                            <img src="05/222.png">
                        </p>
					</section>
				</section>
				<section>
					<section>
						<h4>Удаление узла (delete)</h4>
						<p align="left">Сначала рассмотрим три ситуации удаления узла из двоичного дерева поиска:</p>
						<ol>
							<li>У удаляемого узла нет потомков, тогда мы просто заменим его $NULL$-узлом</li>
							<li>У удаляемого узла один потомок, тогда мы просто запишем потомка вместо удаляемого узла</li>
						</ol>
					</section>
					<section>
						<h4>Удаление узла (delete)</h4>
						<p align="left">Сначала рассмотрим три ситуации удаления узла из двоичного дерева поиска:</p>
						<ol start="3">
							<li>У удаляемого узла есть два потомка, тогда мы найдём наибольший элемент в его левом поддереве, запишем его значение на место удаляемого узла и будем удалять наибольший элемент из его левого поддерева, сводя всё ко второй ситуации</li>
						</ol>
					</section>
					<section>
						<h4>Удаление узла (delete)</h4>
						<p align="left">Теперь, переходя к красно-чёрному дереву, встретим ещё три ситуации:</p>
						<ol>
							<li>Удаляемый узел красный и у него нет потомков</li>
							<li>Удаляемый узел чёрный и у него нет потомков</li>
							<li>Удаляемый узел чёрный и у него есть один потомок</li>
						</ol>
						<p align="left">В первой ситуации просто заменим удаляемый узел на $NULL$-узел. В результате все свойства красно-чёрного дерева сохранятся.</p>
					</section>
					<section>
						<h4>Ситуация $3$</h4>
						<ul>
							<li>Удаляемый узел чёрный и у него есть один потомок</li>
							<li>В таком случае можно доказать, что поддерево-потомок может выглядеть единственным возможным образом</li>
							<li>Тогда заменяем удаляемый элемент его потомком и окрашиваем его в чёрный</li>
						</ul>
					</section>
					<section>
						<h4>Ситуация $3$</h4>
						<p>
                            <img src="05/del_1.png">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2$</h4>
						<ul>
							<li>Удаляемая вершина чёрная и не имеет потомков</li>
							<li>Чтобы представленные далее алгоритмы можно было использовать рекурсивно, стоит её обобщить</li>
							<li>Представим эту вершину в виде корня некоторого поддерева</li>
							<li>В результате удаления количество чёрных узлов на пути до листьев (т.н. чёрная высота) у этого поддерева уменьшается на $1$</li>
						</ul>
					</section>
					<section>
						<h4>Ситуация $2$</h4>
						<p>
                            <img src="05/del_2.png">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2$</h4>
						<ul>
							<li>Будем считать, что поддерево, чёрная высота которого изменилась, – правый потомок своего родителя</li>
							<li>Если в действительности это левый потомок, алгоритмы будут симметричны</li>
							<li>Начнём с ситуации, когда родитель уменьшаемого поддерева красный</li>
							<li>В таком случае у него точно есть чёрный потомок</li>
						</ul>
					</section>
					<section>
						<h4>Ситуация $2.1$</h4>
						<p align="left">Треугольником на рисунке обозначено уменьшаемое поддерево</p>
						<p>
                            <img src="05/del_3.png">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2.1$</h4>
						<ul>
							<li>В таком случае у нас есть две подситуации: когда у чёрного узла есть хотя бы один красный потомок ($2.1.1$) и когда их нет ($2.1.2$)</li>
							<li>Рассмотрим ситуацию, когда он есть, тогда нужно только совершить два поворота и перекрасить один узел</li>
						</ul>
					</section>
					<section>
						<h4>Ситуация $2.1.1$</h4>
						<p>
                            <img src="05/del_4.png">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2.1.2$</h4>
						<ul>
							<li>Теперь рассмотрим ситуацию, когда у $B$ нет красных потомков</li>
							<li>Тогда нам нужно просто поменять цветами $A$ и $B$</li>
						</ul>
						<p>
                            <img src="05/del_6.png" height="70%" width="70%">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2.2$</h4>
						<ul>
							<li>Рассмотрим ситуацию $2.2$, когда родитель уменьшаемого поддерева ($A$) чёрный</li>
							<li>Узел $B$ в таком случае может быть красным ($2.2.1$) или чёрным ($2.2.2$)</li>
						</ul>
					</section>
					<section>
						<h4>Ситуация $2.2.1$</h4>
						<ul>
							<li>Начнём с ситуации, когда $B$ красный</li>
							<li>В таком случае у $B$ точно будет потомок $C$ и это порождает ещё две ситуации: когда у $C$ есть красный потомок ($2.2.1.1$) и когда его нет ($2.2.1.2$)</li>
						</ul>
					</section>
					<section>
						<h4>Ситуация $2.2.1.1$</h4>
						<p>
                            <img src="05/del_7.png">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2.2.1.2$</h4>
						<p>
                            <img src="05/del_8.png">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2.2.2$</h4>
						<ul>
							<li>Теперь рассмотрим ситуацию, когда B – чёрный</li>
							<li>Снова задаёмся вопросом, есть ли у него красные потомки, если да ($2.2.2.1$):</li>
						</ul>
						<p>
                            <img src="05/del_9.png">
                        </p>
					</section>
					<section>
						<h4>Ситуация $2.2.2.1$</h4>
						<p align="left">
							Если у $B$ всё же нет красных потомков, перекрасим $B$ в красный, поднимемся в $A$ (так, что он теперь корень уменьшенного поддерева) и будем рекурсивно повторять алгоритм удаления:
						</p>
						<p>
                            <img src="05/del_10.png">
                        </p>
					</section>
				</section>
				<section>
					<section>
						<h4>Вычислительная сложность</h4>
						<ul>
							<li>Все рассмотренные операции на красно-чёрном дереве выполняются максимум за $O(log_2(N))$</li>
							<li>Ситуации, когда требуются только повороты и перекраска требуют $O(1)$ времени</li>
							<li>Редкие случаи, когда требуется рекурсия занимают $O(log_2(N))$ времени, т.к. при рекурсии всегда происходит спуск или подъём по простому пути</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Реализация в C++</h4>
						<p align="left">На основе красно-чёрных деревьев в C++ реализованы следующие контейнеры:</p>
						<ul>
							<li><code data-trim class="cpp">std::set</code></li>
							<li><code data-trim class="cpp">std::map</code></li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Полезные источники</h4>
						<ol>
							<li><b>RU</b> <a href='https://youtu.be/T70nn4EyTrs'>Лекция</a> преподавателя из МФТИ (более простой алгоритм, который представлен в презентации)</li>
							<li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 13 – Основная книга нашего курса.</li>							
							<li><b>EN</b> <a href='https://www.youtube.com/playlist?list=PL9xmBV_5YoZNqDI8qfOZgzbqahCUmUEin&authuser=0'>Подробное объяснение</a> алгоритмов из книги [2]</li>
						</ol>
					</section>
					<section>
						<h4>Полезные источники</h4>
						<ol start="4">
							<li><b>RU</b> <a href='https://habr.com/ru/companies/otus/articles/472040/'>Статья</a> про балансировку</li>
							<li><b>RU</b> <a href='https://habr.com/ru/companies/otus/articles/521034/'>Статья</a> про удаление узлов</li>
							<li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/RedBlack.html?authuser=0'>Визуализация</a> красно-чёрного дерева</li>
						</ol>
					</section>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>