<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Алгоритмизация и Программирование</h3>
					<div>&nbsp;</div>
					<h4>Морозов Владимир Игоревич</h4>
				</section>
				<section>
					<h4>Расширение структур данных</h4>
				</section>
			
				<section>
					<section>
						<h4>Постановка проблемы</h4>
						<ul>
							<li>На практике могут возникать ситуации, когда структур данных, рассмотренных на предыдущих лекциях, недостаточно для решения поставленной задачи</li>
							<li>Однако очень редко приходится создавать совершенно новую структуру данных</li>
						</ul>
					</section>
					<section>
						<h4>Постановка проблемы</h4>
						<ul>
							<li>Как правило, достаточно расширить одну из рассмотренных структур путём добавления к ней дополнительной информации</li>
							<li>Такое расширение может оказаться нетривиальной задачей, т.к. добавленная информация должна поддерживаться всеми операциями, определёнными для данной структуры</li>
						</ul>
					</section>
				</section>
				
				<section>
					<h4>Алгоритм расширения структуры данных</h4>
					<ol>
						<li>Выбор базовой структуры данных</li>
						<li>Определение дополнительной информации</li>
						<li>Проверка того, что дополнительная информация может поддерживаться основными модифицирующими операциями над базовой структурой данных без ущерба их эффективности</li>
						<li>Разработка новых операций</li>
					</ol>
				</section>
				<section>
					<section>
						<h4>Порядковая статистика</h4>
						<ul>
							<li>Введём определение <b>порядковой статистики</b> некоторого множества элементов</li>
							<li>$i$-ой порядковой статистикой множества из $N$ элементов $(i \in \{1, 2, \ldots, N\})$ является элемент множества с $i$-ым в порядке возрастания ключом</li>
							<li>Например, $5$-ой порядковой статистикой множества $\{9, 7, 2, 8, 6, 3, 4, 1\}$ будет число $6$</li>
						</ul>
					</section>
					<section>
						<h4>Расширение структуры данных для работы с порядковыми статистиками</h4>
						<p align="left">Выполним алгоритм расширения для построения структуры данных, эффективно работающей с порядковыми статистиками</p>
						<ol start="1">
							<li>В качестве базовой структуры данных выберем красно-чёрное дерево, т.к. в нём уже реализован ряд операций с порядковыми статистиками, например, получение минимального и максимального, а также следующего и предыдущего по порядку элементов для заданного</li>
						</ol>
					</section>
					<section>
						<h4>Расширение структуры данных для работы с порядковыми статистиками</h4>
						<ol start="2">
							<li>В качестве дополнительного атрибута добавим к каждому узлу поле $size$, содержащее количество ненулевых узлов в поддереве с корнем в данном узле</li>
						</ol>
						<p>
							<img src="07/rbt_node.png" width="80%" height="80%">
						</p>
					</section>				
					<section>
						<h4>Дерево порядковой статистики</h4>
						<ul>
							<li>Описанное на предыдущем слайде дерево называется <b>деревом порядковой статистики</b></li>
							<li>Пункты $3$ и $4$ алгоритма будут рассмотрены далее</li>
							<li>На следующем слайде представлен пример такого дерева</li>
						</ul>
					</section>
					<section>
						<h4>Дерево порядковой статистики</h4>
						<p>
							<img src="07/tree.png">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Проверка поддержки вставки</h4>
						<p align="left">Вставка узла состоит из двух фаз:</p>
						<ol>
							<li>Проход вниз по простому пути от корня для поиска места вставки</li>
							<li>Повороты в дереве для восстановления свойств после вставки узла</li>
						</ol>
					</section>
					<section>
						<h4>Первая фаза</h4>
						<ul>
							<li>В первой фазе достаточно нарастить $size$ каждого узла на пути на $1$ ($size$ самого узла тоже устанавливается в $1$)</li>
							<li>Т.к. сам проход занимает $O(log_2N)$, а установка атрибута для каждого узла происходит за $O(1)$, результирующая сложность остаётся $O(log_2N)$</li>
						</ul>
					</section>
					<section>
						<h4>Вторая фаза</h4>
						<ul>
							<li>Во второй фазе может быть максимум два поворота</li>
							<li>Т.к. каждый из них происходит за время $O(1)$ и не затрагивает других узлов нужно только переприсвоить атрибуты $size$ у части из них, как показано на рисунке, чтобы получить корректное дерево</li>
							<li>Данная операция тоже производится за $O(1)$</li>
						</ul>
					</section>
					<section>
						<h4>Поворот в дереве порядковой статистики</h4>
						<p>
							<img src="07/rotate.png">
						</p>
					</section>
					<section>
						<h4>Проверка поддержки удаления</h4>
						<ul>
							<li>Удаление узла также содержит фиксированное количество поворотов</li>
							<li>Чтобы сохранить согласованность атрибутов $size$, необходимо пройти по простому восходящему пути от удалённого узла и отнять от каждого атрибута по $1$</li>
							<li>Это действие производится за $O(log_2N)$</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Разработка новых операций</h4>
						<p align="left">Для эффективного оперирования порядковыми статистками дерево порядковой статистики предоставляет две дополнительные операции:</p>
						<ol>
							<li>Выборка элемента с заданным рангом – получение $i$-ой порядковой статистики множества, где $i$ называется рангом элемента</li>
							<li>Определение ранга элемента – получение ранга элемента по его ключу</li>
						</ol>
					</section>
				
					<section>
						<h4>Выборка по рангу</h4>
						<p align="left">Пусть есть ранг искомого элемента $i$ и корень поддерева, в котором производится поиск, $x$ (изначально $x$ – корень всего дерева), тогда:</p>
						<ol>
							<li>Вычислим ранг текущего элемента<br>$r = x.left.size + 1$</li>
							<li>Если $i = r$, заканчиваем работу, текущий элемент и есть искомый</li>
						</ol>
					</section>
					<section>
						<h4>Выборка по рангу</h4>
						<ol start="3">
							<li>Если $i &lt; r$, искомый элемент находится в левом поддереве для данного, рекурсивно повторяем процедуру, взяв $i = i$, $x = x.left$</li>
							<li>Если $i &gt; r$, искомый элемент находится в правом поддереве для данного, рекурсивно повторяем процедуру, взяв $i = i - r$,<br>$x = x.right$</li>
						</ol>
					</section>
					<section>
						<h4>псевдокод выборки по рангу</h4>
						<p>
							<img src="07/select.png">
						</p>
					</section>
					
					<section>
						<h4>Определение ранга</h4>
						<p align="left">
							Алгоритм определения ранга элеменат строится исходя из следующих соображений:
						</p>
						<ol>
							<li>Ранг элемента – количество узлов, которые нужно пройти при обходе дерева, чтобы дойти до данного</li>
							<li>Обход дерева всегда осуществляется в порядке: левое поддерево $\rightarrow$ корень $\rightarrow$ правое поддерево</li>
							<li>Тогда ранг элемента не меньше, чем размер его левого поддерева $+1$</li>
						</ol>
					</section>
					<section>
						<h4>Определение ранга</h4>
						<p>
							<img src="07/rank_min_border.png" height="70%" width="70%">
						</p>
					</section>
					<section>
						<h4>Определение ранга</h4>
						<ol start="4">
							<li>Если искомый узел является узлом какого-либо правого поддерева, то, чтобы дойти до него при обходе, нужно обойти сначала соответствующее левое поддерево</li>
							<li>Причём таких поддеревьев будет столько, для скольких узлов на пути до корня искомый узел находится в правом поддереве</li>
						</ol>
					</section>
					<section>
						<h4>Определение ранга</h4>
						<p align="left">
							Треугольниками обозначены поддеревья, которые необходимо обойти до узла $x$
						</p>
						<p>
							<img src="07/rank_when_in_right.png">
						</p>
					</section>
					<section>
						<h4>Определение ранга</h4>
						<p align="left">
							Пусть задан некоторый элемент $x$ дерева $T$. Тогда поиск его ранга будет производиться следующим образом:
						</p>
						<p>
							<img src="07/ident.png">
						</p>
					</section>
					<section>
						<h4>Сложность новых операций</h4>
						<ul>
							<li>Т.к. при поиске элемента по рангу на каждом этапе рекурсии производится спуск вниз на один уровень дерева, сложность этой операции <b>$O(log_2N)$</b></li>
							<li>Т.к. при получении ранга элемента на каждой итерации производится подъём на один уровень вверх по дереву, сложность этой операции также <b>$O(log_2N)$</b></li>
						</ul>
					</section>
					<section>
						<h4>Применение выборки по рангу</h4>
						<ul>
							<li>Выборка по рангу позволяет получить $i$-ый по порядку обхода элемент в двоичном дереве</li>
							<li>Это свойство может использоваться, например, при разработке итераторов произвольного доступа для двоичных деревьев</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Отрезки</h4>
						<ul>
							<li><b>Отрезком</b> называется упорядоченная пара действительных чисел $[t_1, t_2]$ таких, что<br>$t_1 \leq t_2$</li>
							<li>Таким образом, каждый отрезок представляет множество действительных чисел, заключённых между его границами</li>
							<li>С помощью отрезков удобно оперировать промежутками времени, например, при составлении расписаний</li>
						</ul>
					</section>
					<section>
						<h4>Трихотомия отрезков</h4>
						<p align="left">Если дано два отрезка, они могут находиться только в одном из трёх состояний:</p>
						<ol start="1">
							<li>Отрезки перекрываются, т.е. левая граница одного отрезка всегда меньше по значению, чем правая граница другого</li>
						</ol>
					</section>
					<section>
						<h4>Трихотомия отрезков</h4>
						<ol start="2">
							<li>Первый отрезок находится слева от второго, т.е. правая граница первого меньше левой границы второго</li>
						</ol>
					</section>
					<section>
						<h4>Трихотомия отрезков</h4>
						<ol start="3">
							<li>Первый отрезок находится справа от второго, т.е. правая граница второго меньше левой границы первого</li>
						</ol>
						<p align="left">Это называется <b>трихотомией отрезков</b></p>
					</section>
					<section>
						<h4>Трихотомия отрезков</h4>
						<p>
							<img src="07/int_trich.png">
						</p>
					</section>
				</section>
				
				<section>
					<section>
						<h4>Дерево отрезков</h4>
						<ul>
							<li><b>Деревом отрезков</b> называется красно-чёрное дерево, каждый элемент которого содержит некоторый отрезок</li>
							<li>При этом ключом является левая граница этого отрезка</li>
							<li>В качестве дополнительной информации каждый узел содержит атрибут $max$, содержащий максимальное значение всех правых границ отрезков в поддереве с корнем в данном узле</li>
						</ul>
					</section>
					<section>
						<h4>Дерево отрезков</h4>
						<p>
							<img src="07/int_tree.png" height="70%" width="70%" >
						</p>
					</section>
					<section>
						<h4>Операции на дереве отрезков</h4>
						<p align="left">Дерево отрезков поддерживает следующие операции:</p>
						<ol>
							<li>Вставка отрезка в дерево</li>
							<li>Удаление отрезка из дерева</li>
							<li>Поиск в дереве отрезка, перекрывающегося с данным</li>
						</ol>
					</section>
					<section>
						<h4>Поддержка дополнительной информации</h4>
						<ul>
							<li>Чтобы поддерживать дополнительную информацию (атрибут $max$) в каждой из этих операций, на каждом шаге требуется за $O(1)$ вычислить максимальное значение из правой границы данного отрезка и атрибутов $max$ его правого и левого поддеревьев</li>
							<li>Следовательно, поддержка дополнительной информации не влияет на сложность остальных операций</li>
						</ul>
					</section>
				</section>
				
				<section>
					<section>
						<h4>Введение новых операций</h4>
						<p align="left">Единственной принципиально новой для красно-чёрного дерева операцией в дереве отрезков является поиск отрезка, перекрывающегося с данным</p>
					</section>
					<section>
						<h4>Алгоритм поиска</h4>
						<p align="left">Чтобы понять, как построен алгоритм поиска, установим, что поиск начинается с корня, и рассмотрим три ситуации:</p>
						<ol>
							<li>Представленный отрезок пересекается с отрезком в текущем узле дерева – в таком случае алгоритм завершён, отрезок в текущем узле дерева и есть искомый</li>
						</ol>
					</section>
					<section>
						<h4>Ситуация $2$</h4>
						<ol start="2">
							<li>Представленный отрезок стоит слева от отрезка в текущем узле дерева – тогда необходимо продолжить поиск в левом поддереве, т.к. в правом поддереве левые границы отрезков ещё больше, соответственно, пересечений там найдено не будет</li>
						</ol>
					</section>
					<section>
						<h4>Описание рисунков</h4>
						<p align="left">На последующих рисунках:</p>
						<ul>
							<li>Линия с одной точкой означает начало отрезка</li>
							<li>Синим выделен представленный отрезок</li>
							<li>В качестве $root$ обозначен отрезок в текущем узле дерева</li>
							<li>Чёрный пунктир – разделение левого и правого поддеревьев для корня $root$</li>
							<li>Красный пунктир – расположения значения $max$ для поддерева</li>
						</ul>
					</section>
					<section>
						<h4>Ситуация $2$</h4>
						<p>
							<img src="07/sit_2.png">
						</p>
					</section>
					<section>
						<h4>Ситуация $3.1$</h4>
						<ol start="3">
							<li>
								Представленный отрезок стоит справа от отрезка в текущем узле дерева – здесь нельзя принять однозначное решение, есть две подситуации:
								<ul>
									<li>В левом поддереве нет отрезка, правый конец которого больше, чем левый конец представленного отрезка – в таком случае необходимо продолжить поиск в правом поддереве, т.к. в левом все отрезки стоят левее заданного</li>
								</ul>
							</li>
						</ol>
					</section>
					<section>
						<h4>Ситуация $3.1$</h4>
						<p>
							<img src="07/sit_3_1.png">
						</p>
					</section>
					<section>
						<h4>Ситуация $3.2$</h4>
						<ol start="3">
							<li>
								<ul>
									<li>В левом поддереве есть отрезок, правый конец которого больше, чем левый конец представленного отрезка – в таком случае необходимо продолжить поиск в левом поддереве, т.к.:
										<ul>
											<li>Наличие такого отрезка показывает, что пересечение возможно</li>
											<li>Т.к. в левом поддереве все левые границы меньше, чем левая граница текущего узла дерева, то в левом поддереве обязательно найдётся пересечение</li>
										</ul>
									</li>
								</ul>
							</li>
						</ol>
					</section>
					<section>
						<h4>Ситуация $3.2$</h4>
						<p>
							<img src="07/sit_3_2.png">
						</p>
					</section>
					<section>
						<h4>Обозначения</h4>
						<p align="left">Примем следующие обозначения:</p>
						<ul>
							<li>$i$ – данный отрезок, представленный парой атрибутов $i.high$ и $i.low$</li>
							<li>$T$ – корень дерева из узлов, каждый из которых содержит отрезок $int$ и атрибут $max$</li>
							<li>$T.nil$ – нулевой (терминирующий) узел для данного дерева</li>
							<li>$T.root$ – корень данного дерева</li>
						</ul>
					</section>
				
					<section>
						<h4>Поиск перекрывающегося отрезка</h4>
						<p align="left">Принимая во внимание обозначения с предыдущего слайда, можно представить алгоритм поиска в виде псевдокода:</p>
						<p>
							<img src="07/search.png">
						</p>
					</section>
					
					<section>
						<h4>Сложность поиска</h4>
						<p align="left">Т.к. присваивания на строках $4$ и $5$ псевдокода осуществляют спуск по дереву по простому нисходящему пути, очевидно, что сложность данного алгоритма составляет <b>$O(log_2N)$</b></p>
					</section>
				</section>
				
				<section>
					<h4>Полезные источники</h4>
					<ol>
						<li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 14</li>							
					</ol>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>