<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="mobile-web-app-capable" content="yes">

		<title>Алгоритмизация и Программирование</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Алгоритмизация и Программирование</h3>
					<div>&nbsp;</div>
					<h4>Морозов Владимир Игоревич</h4>
				</section>
				<section>
					<h4>Графы<br>Элементарные алгоритмы</h4>
				</section>			
				<section>
					<section>
						<h4>Определение графа</h4>
						<ul>
							<li>
								Граф – структура данных, которая может быть описана двумя множествами:
								<ol>
									<li>Множеством вершин графа $V$</li>
									<li>Множеством рёбер графа $E$</li>
								</ol>
							</li>
							<li>При этом каждое ребро соединяет какую-либо пару вершин</li>
						</ul>
					</section>
					<section>
						<h4>Визуализация графа</h4>
						<p>
							<img src="08/simple_graph.png">
						</p>
					</section>
					<section>
						<h4>Ориентированный граф</h4>
						<p align="left">
							Если рёбра графа имеют направление, такой граф называется <b>ориентированным</b>
						</p>
						<p>
							<img src="08/simple_orgraph.png">
						</p>
					</section>
				</section>				
				<section>
					<section>
						<h4>Представление графа</h4>
						<p align="left">
							Для программной обработки граф может быть представлен в двух видах:
						</p>
						<ol>
							<li>Списки смежных вершин – массив из связных списков, головной элемент каждого из которых соответствует каждой из вершин графа, а остальные элементы – тем вершинам, с которыми связана данная</li>
						</ol>
					</section>
					<section>
						<h4>Представление графа</h4>
						<ol start="2">
							<li>Матрица смежности – матрица размера<br>$|V|\times|V|$, каждая строка и столбец которой соответствуют определённой вершине графа; если между вершинами есть ребро, на пересечении соответствующей строки и столбца ставится $1$, иначе – $0$</li>
						</ol>
						<p align="left">
							Матрицы смежности неэффективны для хранения разреженных графов – графов с большим колчеством вершин и малым количеством связей
						</p>
					</section>
					<section>
						<h4>Представление неориентированного графа</h4>
						<p>
							<img src="08/graph_repr.png">
						</p>
					</section>
					<section>
						<h4>Представление ориентированного графа</h4>
						<p>
							<img src="08/orgraph_repr.png">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Элементарные алгоритмы на графах</h4>
						<ul>
							<li>Наиболее простыми и фундаментальными алгоритмами для обработки графов являются алгоритмы <b>обхода</b></li>
							<li>Это алгоритмы, позволяющие получить доступ ко всем вершинам графа в определённом порядке</li>
							<li>Существует два базовых алгоримта обхода графов: <b>поиск в ширину</b> и <b>поиск в глубину</b></li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Поиск в ширину</h4>
						<ul>
							<li>Поиск в ширину – один из простейших алгоритмов для обхода графа, который часто используется более сложными алгоритмами</li>
							<li>Поиск в ширину имеет такое название, потому что, прежде чем приступать к обходу вершин на расстоянии $d = k + 1$ от данной, обходятся все вершины на расстоянии $d = k$</li>
						</ul>
					</section>
					<section>
						<h4>Поиск в ширину</h4>
						<ul>
							<li>Поиск в ширину обходит все вершины заданного графа, достижимые из заданной начальной вершины, а также имеет полезное побочное действие</li>
							<li>В процессе обхода алгоритм поиска в ширину строит <b>дерево поиска в ширину</b>, каждый путь от корня которого к любой из его вершин соответствует кратчайшему пути между данными вершинами на графе</li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм поиска в ширину</h4>
						<ul>
							<li>Пусть задан граф $G = (V, E)$</li>
							<li>Для выполнения на нём поиска в ширину необходимо прежде всего задать исходную вершину $s$, с которой будет начат обход и которая станет корнем дерева</li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм поиска в ширину</h4>
						<p align="left">
							Также необходимо задать следующие дополнительные свойства всем вершинам:
						</p>
						<ol>
							<li><b>Цвет</b> – каждая вершина может быть белого, серого или чёрного цвета</li>
							<li><b>Родитель</b> – для каждой вершины (кроме $s$) в процессе обхода задаётся родительская вершина – та, которая будет над ней в дереве поиска в ширину</li>
							<li><b>Расстояние</b> ($d$) – количество рёбер, которые нужно пройти от $s$ до данной вершины</li>
						</ol>
					</section>
					<section>
						<h4>Алгоритм поиска в ширину</h4>
						<p align="left">
							Цвета используются следующим образом:
						</p>
						<ol>
							<li>Белым помечаются ещё не просмотренные вершины</li>
							<li>Серым помечаются уже просмотренные вершины</li>
							<li>Чёрным помечаются вершины, все смежные вершины которых были просмотрены</li>
						</ol>
						<p align="left">
							Также для поиска в ширину вводится вспомогательная очередь (FIFO) – $Q$
						</p>
					</section>
					<section>
						<h4>Алгоритм поиска в ширину</h4>
						<p align="left">
							Алгоритм поиска в ширину делится на две части:
						</p>
						<ol>
							<li>Инициализация</li>
							<li>Обход</li>
						</ol>
					</section>
					<section>
						<h4>Инициализация</h4>
						<ol>
							<li>
								Для всех вершин, кроме $s$, установить:
								<ul>
									<li>Цвет – белый</li>
									<li>Расстояние $d = \infty$</li>
									<li>Родитель – $NULL$ (не определён)</li>
								</ul>
							</li>
							<li>
								Для $s$ установить:
								<ul>
									<li>Цвет – серый</li>
									<li>Расстояние $d = 0$</li>
									<li>Родитель – $NULL$ (не определён)</li>
								</ul>
							</li>
							<li>Поместить вершину $s$ в очередь $Q$</li>
						</ol>
					</section>
					<section>
						<h4>Обход</h4>
						<p align="left">
							Пока очередь $Q$ не пуста, выполнять:
						</p>
						<ol>
							<li>Текущей вершине $u$ присвоить элемент извлечённый из очереди</li>
						</ol>
					</section>
					<section>
						<h4>Обход</h4>
						<ol start="2">
							<li>
								Для всех белых вершин $v_i$, смежных с $u$, выполнять:						
								<ul>
									<li>Окрасить вершину $v_i$ в серый цвет</li>
									<li>Атрибуту $d$ для $v_i$ присвоить значение $u.d + 1$</li>
									<li>Родителем вершины $v_i$ сделать вершину $u$</li>
									<li>Поместить вершину $v_i$ в очередь $Q$</li>
								</ul>
							</li>
							<li>Окрасить вершину $u$ в чёрный цвет</li>
						</ol>
					</section>
					<section>
						<h4>Дерево поиска в ширину</h4>
						<ul>
							<li>Простой путь от его корня дерева поиска в ширину до любой из вершин является кратчайшим путём из вершины $s$ до этой вершины</li>
							<li>Более того, благодаря этому свойству, можно вывести список всех вершин, находящихся на кратчайшем пути от $s$ до данной, просто поднявшись по простому восходящему пути в дереве от данной вершины до корня и записав пройденные вершины в обратном порядке</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h4>Поиск в глубину</h4>
						<ul>
							<li>Основная идея данного алгоритма в том, что он исследует все вершины, смежные с последней исследованной, до тех пор, пока у последней исследованной вершины не останется неисследованных рёбер, таким образом проходя &laquo;вглубь&raquo; графа</li>
							<li>После этого происходит откат к предыдущей исследованной вершине</li>
						</ul>
					</section>
					<section>
						<h4>Поиск в глубину</h4>
						<ul>
							<li>В отличие от поиска в ширину, данный алгоритм гарантированно обходит все вершины графа, даже те, которые не достижимы из заданной</li>
							<li>Для этого после обхода всех вершин, достижимых из заданной, выбирается новая исходная вершина и обход повторяется</li>
						</ul>
					</section>
					<section>
						<h4>Поиск в глубину</h4>
						<ul>
							<li>Поиск в глубину тоже организует рассмотренные вершины в древовидную структуру</li>
							<li>Однако, т.к. исходных вершин может быть несколько, деревьев поиска тоже получается несколько и они образуют <b>лес поиска в глубину</b></li>
							<li>Все атрибуты вершин, принятые для поиска в ширину сохраняются, однако добавляются и новые</li>
						</ul>
					</section>
					<section>
						<h4>Метки времени</h4>
						<ul>
							<li>Поиск в глубину при обходе проставляет в вершинах <b>метки времени</b> $d$ и $f$</li>
							<li>Метка $d$ ставится в момент, когда вершины окрашивается в серый цвет, а $f$ – когда вершина окрашивается в чёрный</li>
							<li>Таким образом, эти метки отмечают начало и завершение работы с вершиной</li>
						</ul>
					</section>
					<section>
						<h4>Измерение времени</h4>
						<ul>
							<li>Время в данном случае – целое число в диапазоне $[0, 2|V|]$, равное порядковому номеру операции окрашивания для данного запуска алгоритма</li>
						</ul>
					</section>
					<section>
						<h4>Алгоритм поиска в глубину</h4>
						<ul>
							<li>Алгоритм поиска в глубину принимает на вход только сам граф и включает две части: общий обход и посещение вершины</li>
							<li>Для подсчёта времени используется глобальная переменная</li>
						</ul>
					</section>
					<section>
						<h4>Общий обход</h4>
						<ol>
							<li>
								Для всех вершин графа установить:
								<ul>
									<li>Цвет – белый</li>
									<li>Родитель – $NULL$ (не определён)</li>
								</ul>
							</li>
							<li>Текущее значение метки времени установить в $0$</li>
							<li>
								Для всех вершин графа:
								<ul>
									<li>Если вершина белая, посетить вершину</li>
								</ul>
							</li>
						</ol>
					</section>
					<section>
						<h4>Посещение вершины</h4>
						<ol>
							<li>Увеличить значение текущей метки времени на $1$</li>
							<li>Метке $d$ текущей вершины $u$ присвоить значение текущей метки времени</li>
							<li>Окрасить текущую вершину $u$ в серый цвет</li>
							<li>
								Для всех белых вершин $v_i$, смежных с $u$, выполнить:
								<ul>
									<li>Назначить родителем $v_i$ вершину $u$</li>
									<li>Посетить вершину $v_i$</li>
								</ul>
							</li>
						</ol>
					</section>
					<section>
						<h4>Посещение вершины</h4>
						<ol start="5">
							<li>Окрасить текущую вершину $u$ в чёрный</li>
							<li>Увеличить значение текущей метки времени на $1$</li>
							<li>Метке $f$ текущей вершины $u$ присвоить значение текущей метки времени</li>
						</ol>
					</section>
					<section>
						<h4>Свойства поиска в глубину</h4>
						<p align="left">
							Алгоритм поиска в глубину, а также лес поиска и метки времени, получающиеся в результате его работы, имеют широкий ряд свойств, смысл большинства из которых будет понятен позже. Поэтому рассмотрим только некоторые из них:
						</p>
						<ol>
							<li>Теорема о скобках</li>
							<li>Топологическая сортировка</li>
						</ol>
					</section>
				</section>
				<section>
					<section>
						<h4>Теорема о скобках</h4>
						<p align="left">
							В результате любого поиска в глубину на графе $G$ для любой пары вершин $u$ и $v$ графа $G$ выполняется только одно из следующих свойств:
						</p>
						<ol>
							<li>Отрезки $[u.d, u.f]$ и $[v.d, v.f]$ не пересекаются и ни одна из вершин не является потомком другой в лесу поиска в глубину</li>
							<li>Отрезок $[u.d, u.f]$ полностью содержится в отрезке $[v.d, v.f]$, а $u$ является потомком $v$ в дереве поиска в глубину</li>
						</ol>
					</section>
					<section>
						<h4>Теорема о скобках</h4>
						<ol start="3">
							<li>Отрезок $[v.d, v.f]$ полностью содержится в отрезке $[u.d, u.f]$, а $v$ является потомком $u$ в дереве поиска в глубину</li>
						</ol>
						<p align="left">
							Таким образом, вершина $v$ является потомком $u$ в дереве поиска в глубину тогда и только тогда, когда: $u.d &lt; v.d &lt; v.f &lt; u.f$
						</p>
					</section>
					<section>
						<h4>Теорема о скобках</h4>
						<p align="left">
							Из теоремы о скобках следует, что метки открытия и завершения на вершинах образуют правильную скобочную структуру
						</p>
					</section>
					<section>
						<h4>Визуализация теоремы о скобках</h4>
						<p>
							<img src="08/dfs.png" width="50%" height="50%">
						</p>
						<p>
							<img src="08/parentheses.png" width="50%" height="50%">
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Топологическая сортировка</h4>
						<ul>
							<li>Топологическая сортировка ориентированного ациклического графа – такое упорядочение всех его вершин вдоль горизонтальной линии, что все рёбра направлены слева направо</li>
							<li>Для примера рассмотрим граф одевания</li>
						</ul>
					</section>
					<section>
						<h4>Граф одевания</h4>
						<p>
							<img src="08/seq_graph.png">
						</p>
					</section>
					<section>
						<h4>Описание графа</h4>
						<ul>
							<li>Вершины на представленном графе представляют предметы гардероба</li>
							<li>Ребро, направленное из вершины $u$ в вершину $v$ означает, что вещь $u$ должна быть надета раньше вещи $v$</li>
						</ul>
					</section>
					<section>
						<h4>Свойства топологической сортировки</h4>
						<ul>
							<li>Если подвергнуть представленный граф топологической сортировке, получится правильный порядок одевания</li>
							<li>Это свойство можно обобщить для множества задач о последовательностях некоторых событий</li>
						</ul>
						<p>
							<img src="08/seq_one_line.png">
						</p>
					</section>
					<section>
						<h4>Алгоритм топологической сортировки</h4>
						<ol>
							<li>Выполнить поиск в глубину для графа $G$</li>
							<li>По завершении работы над каждой вершиной $v$ графа $G$ помещать её в начало связного списка</li>
							<li>Полученный связный список считать результатом топологической сортировки</li>
						</ol>
						<p align="left">
							Таким образом, топологическая сортировка – сортировка по убыванию времени завершения работы с вершиной
						</p>
					</section>
				</section>
				<section>
					<section>
						<h4>Сложность элементарных алгоритмов на графе</h4>
						<table>
							<tr>
								<th>Операция</th> <th>Сложность</th>
							</tr>
							<tr>
								<td>Поиск в ширину</td> <td>$O(|V|+|E|)$</td>
							</tr>
							<tr>
								<td>Поиск в глубину</td> <td>$\Theta(|V|+|E|)$</td>
							</tr>
							<tr>
								<td>Топологическая сортировка</td> <td>$\Theta(|V|+|E|)$</td>
							</tr>
						</table>						
					</section>
				</section>
				<section>
					<h4>Полезные источники</h4>
					<ol>
						<li><b>RU</b> Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание. Глава 22</li>
						<li><b>RU</b> <a href='https://drive.google.com/file/d/1gNDB8DrIa2O-w9zap70QDWnIRh5BL1Z5/view'>Альтернативная презентация</a> про обходы графов</li>
						<li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/BFS.html'>Визуализация</a> поиска в ширину</li>
						<li><b>EN</b> <a href='https://www.cs.usfca.edu/~galles/visualization/DFS.html'>Визуализация</a> поиска в глубину</li>
					</ol>
				</section>
			</div>
		</div>

		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2 ]
			});
		</script>
	</body>
</html>